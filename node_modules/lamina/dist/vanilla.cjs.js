'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var three = require('three');

const BlendModes = {
  normal: 1,
  add: 2,
  subtract: 3,
  multiply: 4,
  addsub: 5,
  lighten: 6,
  darken: 7,
  switch: 8,
  divide: 9,
  overlay: 10,
  screen: 11,
  softlight: 12
};

class Abstract {
  static genID() {
    return three.MathUtils.generateUUID().replaceAll('-', '_');
  }

  getBlendMode(type, a, b) {
    if (type === BlendModes['normal']) return `sc_copy(${a}, ${b})`;else if (type === BlendModes['add']) return `sc_add(${a}, ${b})`;else if (type === BlendModes['subtract']) return `sc_subtract(${a}, ${b})`;else if (type === BlendModes['multiply']) return `sc_multiply(${a}, ${b})`;else if (type === BlendModes['addsub']) return `sc_addSub(${a}, ${b})`;else if (type === BlendModes['lighten']) return `sc_lighten(${a}, ${b})`;else if (type === BlendModes['darken']) return `sc_darken(${a}, ${b})`;else if (type === BlendModes['divide']) return `sc_divide(${a}, ${b})`;else if (type === BlendModes['overlay']) return `sc_overlay(${a}, ${b})`;else if (type === BlendModes['screen']) return `sc_screen(${a}, ${b})`;else if (type === BlendModes['softlight']) return `sc_softLight(${a}, ${b})`;
  }

  getVertexVariables() {
    return '';
  }

  getVertexBody(e) {
    return '';
  }

}

class Base extends Abstract {
  constructor(props) {
    super();
    this.name = 'Base';
    this.mode = 'normal';
    this.uuid = Abstract.genID();
    const {
      color,
      alpha,
      mode
    } = props || {};
    this.uniforms = {
      [`u_${this.uuid}_color`]: {
        value: new three.Color(color != null ? color : '#ffffff')
      },
      [`u_${this.uuid}_alpha`]: {
        value: alpha != null ? alpha : 1
      }
    };
    this.mode = BlendModes[mode || 'normal'];
  }

  getFragmentVariables() {
    return `    
    // SC: Base layer uniforms **********
    uniform float u_${this.uuid}_alpha;
    uniform vec3 u_${this.uuid}_color;
    // ************************************
`;
  }

  getFragmentBody(e) {
    return `    
      // SC: Base layer frag-shader-code ***************************************************
      ${e} = ${this.getBlendMode(BlendModes[this.mode], e, `vec4(u_${this.uuid}_color, u_${this.uuid}_alpha)`)};
      // *************************************************************************************
  `;
  }

  set color(v) {
    this.uniforms[`u_${this.uuid}_color`].value = new three.Color(v);
  }

  get color() {
    return this.uniforms[`u_${this.uuid}_color`].value;
  }

  set alpha(v) {
    this.uniforms[`u_${this.uuid}_alpha`].value = v;
  }

  get alpha() {
    return this.uniforms[`u_${this.uuid}_alpha`].value;
  }

}

class Depth extends Abstract {
  constructor(props) {
    super();
    this.name = 'Depth';
    this.mode = 'normal';
    this.uuid = Abstract.genID();
    const {
      alpha,
      mode,
      colorA,
      colorB,
      near,
      far,
      origin,
      isVector
    } = props || {};
    this.uniforms = {
      [`u_${this.uuid}_alpha`]: {
        value: alpha != null ? alpha : 1
      },
      [`u_${this.uuid}_near`]: {
        value: near != null ? near : 700
      },
      [`u_${this.uuid}_far`]: {
        value: far != null ? far : 1e7
      },
      [`u_${this.uuid}_origin`]: {
        value: origin != null ? origin : new three.Vector3(0, 0, 0)
      },
      [`u_${this.uuid}_colorA`]: {
        value: new three.Color(colorA != null ? colorA : '#ffffff')
      },
      [`u_${this.uuid}_colorB`]: {
        value: new three.Color(colorB != null ? colorB : '#ffffff')
      },
      [`u_${this.uuid}_isVector`]: {
        value: isVector != null ? isVector : true
      }
    };
    this.mode = BlendModes[mode || 'normal'];
  }

  getVertexVariables() {
    return (
      /* glsl */
      `
    varying vec3 v_${this.uuid}_worldPosition;
    `
    );
  }

  getVertexBody(e) {
    return (
      /* glsl */
      `
    v_${this.uuid}_worldPosition = vec3(vec4(position, 1.0) * modelMatrix);
    `
    );
  }

  getFragmentVariables() {
    return (
      /* glsl */
      `    
    // SC: Fresnel layer variables **********
    uniform float u_${this.uuid}_alpha;
    uniform float u_${this.uuid}_near;
    uniform float u_${this.uuid}_far;
    uniform float u_${this.uuid}_isVector;
    uniform vec3 u_${this.uuid}_origin;
    uniform vec3 u_${this.uuid}_colorA;
    uniform vec3 u_${this.uuid}_colorB;

    varying vec3 v_${this.uuid}_worldPosition;
    // ************************************
`
    );
  }

  getFragmentBody(e) {
    return (
      /* glsl */
      `    
      // SC: Depth layer frag-shader-code ***************************************************
     
      vec3 f_${this.uuid}_base = ( u_${this.uuid}_isVector > 0.5 ) ?  u_${this.uuid}_origin : cameraPosition;
      float f_${this.uuid}_dist = length( v_${this.uuid}_worldPosition.xyz - f_${this.uuid}_base );
      float f_${this.uuid}_dep = ( f_${this.uuid}_dist - u_${this.uuid}_near ) / ( u_${this.uuid}_far - u_${this.uuid}_near );

      vec3 f_${this.uuid}_depth =  mix( u_${this.uuid}_colorB, u_${this.uuid}_colorA, 1.0 - clamp( f_${this.uuid}_dep, 0., 1. ) );

      ${e} = ${this.getBlendMode(BlendModes[this.mode], e, `vec4(f_${this.uuid}_depth, u_${this.uuid}_alpha)`)};
      // *************************************************************************************
  `
    );
  }

  set alpha(v) {
    this.uniforms[`u_${this.uuid}_alpha`].value = v;
  }

  get alpha() {
    return this.uniforms[`u_${this.uuid}_alpha`].value;
  }

  set near(v) {
    this.uniforms[`u_${this.uuid}_near`].value = v;
  }

  get near() {
    return this.uniforms[`u_${this.uuid}_near`].value;
  }

  set far(v) {
    this.uniforms[`u_${this.uuid}_far`].value = v;
  }

  get far() {
    return this.uniforms[`u_${this.uuid}_far`].value;
  }

  set origin(v) {
    this.uniforms[`u_${this.uuid}_origin`].value = v;
  }

  get origin() {
    return this.uniforms[`u_${this.uuid}_origin`].value;
  }

  set colorA(v) {
    this.uniforms[`u_${this.uuid}_colorA`].value = new three.Color(v);
  }

  get colorA() {
    return this.uniforms[`u_${this.uuid}_colorA`].value;
  }

  set colorB(v) {
    this.uniforms[`u_${this.uuid}_colorB`].value = new three.Color(v);
  }

  get colorB() {
    return this.uniforms[`u_${this.uuid}_colorB`].value;
  }

  set isVector(v) {
    this.uniforms[`u_${this.uuid}_isVector`].value = v;
  }

  get isVector() {
    return this.uniforms[`u_${this.uuid}_isVector`].value;
  }

}

class Fresnel extends Abstract {
  constructor(props) {
    super();
    this.name = 'Fresnel';
    this.mode = 'normal';
    this.uuid = Abstract.genID();
    const {
      alpha,
      mode,
      color,
      bias,
      intensity,
      power
    } = props || {};
    this.uniforms = {
      [`u_${this.uuid}_alpha`]: {
        value: alpha != null ? alpha : 1
      },
      [`u_${this.uuid}_color`]: {
        value: new three.Color(color != null ? color : '#ffffff')
      },
      [`u_${this.uuid}_bias`]: {
        value: bias != null ? bias : 0
      },
      [`u_${this.uuid}_intensity`]: {
        value: intensity != null ? intensity : 1
      },
      [`u_${this.uuid}_power`]: {
        value: power != null ? power : 2
      }
    };
    this.mode = BlendModes[mode || 'normal'];
  }

  getVertexVariables() {
    return (
      /* glsl */
      `
    varying vec3 v_${this.uuid}_worldPosition;
    varying vec3 v_${this.uuid}_worldNormal;
    `
    );
  }

  getVertexBody(e) {
    return (
      /* glsl */
      `
    v_${this.uuid}_worldPosition = normalize(vec3(modelViewMatrix * vec4(position, 1.0)).xyz);
    v_${this.uuid}_worldNormal = normalize(normalMatrix * normal);
    `
    );
  }

  getFragmentVariables() {
    return (
      /* glsl */
      `    
    // SC: Fresnel layer variables **********
    uniform float u_${this.uuid}_alpha;
    uniform vec3 u_${this.uuid}_color;
    uniform float u_${this.uuid}_bias;
    uniform float u_${this.uuid}_intensity;
    uniform float u_${this.uuid}_power;
    uniform float u_${this.uuid}_factor;

    varying vec3 v_${this.uuid}_worldPosition;
    varying vec3 v_${this.uuid}_worldNormal;
    // ************************************
`
    );
  }

  getFragmentBody(e) {
    return (
      /* glsl */
      `    
      // SC: Fresnel layer frag-shader-code ***************************************************
      float f_${this.uuid}_a = ( 1.0 - -min(dot(v_${this.uuid}_worldPosition, normalize(v_${this.uuid}_worldNormal) ), 0.0) );
      float f_${this.uuid}_fresnel = u_${this.uuid}_bias + (u_${this.uuid}_intensity * pow(f_${this.uuid}_a, u_${this.uuid}_power));

      ${e} = ${this.getBlendMode(BlendModes[this.mode], e, `vec4(u_${this.uuid}_color * f_${this.uuid}_fresnel, u_${this.uuid}_alpha)`)};
      // *************************************************************************************
  `
    );
  }

  set alpha(v) {
    this.uniforms[`u_${this.uuid}_alpha`].value = v;
  }

  get alpha() {
    return this.uniforms[`u_${this.uuid}_alpha`].value;
  }

  set color(v) {
    this.uniforms[`u_${this.uuid}_color`].value = new three.Color(v);
  }

  get color() {
    return this.uniforms[`u_${this.uuid}_color`].value;
  }

  set bias(v) {
    this.uniforms[`u_${this.uuid}_bias`].value = v;
  }

  get bias() {
    return this.uniforms[`u_${this.uuid}_bias`].value;
  }

  set intensity(v) {
    this.uniforms[`u_${this.uuid}_intensity`].value = v;
  }

  get intensity() {
    return this.uniforms[`u_${this.uuid}_intensity`].value;
  }

  set power(v) {
    this.uniforms[`u_${this.uuid}_power`].value = v;
  }

  get power() {
    return this.uniforms[`u_${this.uuid}_power`].value;
  }

}

class Noise$2 extends Abstract {
  constructor(props) {
    super();
    this.name = 'Noise';
    this.mode = 'normal';
    this.uuid = Abstract.genID();
    const {
      alpha,
      mode,
      scale,
      color
    } = props || {};
    this.uniforms = {
      [`u_${this.uuid}_alpha`]: {
        value: alpha != null ? alpha : 1
      },
      [`u_${this.uuid}_scale`]: {
        value: scale != null ? scale : 1
      },
      [`u_${this.uuid}_color`]: {
        value: new three.Color(color != null ? color : '#ffffff')
      }
    };
    this.mode = BlendModes[mode || 'normal'];
  }

  getVertexVariables() {
    return (
      /* glsl */
      `
    varying vec2 v_${this.uuid}_uv;
    `
    );
  }

  getVertexBody(e) {
    return (
      /* glsl */
      `
    v_${this.uuid}_uv = uv;
    `
    );
  }

  getFragmentVariables() {
    return (
      /* glsl */
      `    
    // SC: Fresnel layer variables **********
    uniform float u_${this.uuid}_alpha;
    uniform vec3 u_${this.uuid}_color;
    uniform float u_${this.uuid}_scale;

    varying vec2 v_${this.uuid}_uv;
    // ************************************
`
    );
  }

  getFragmentBody(e) {
    return (
      /* glsl */
      `    
      // SC: Fresnel layer frag-shader-code ***************************************************
      float f_${this.uuid}_noise = sc_rand(v_${this.uuid}_uv * u_${this.uuid}_scale);

      ${e} = ${this.getBlendMode(BlendModes[this.mode], e, `vec4(u_${this.uuid}_color * f_${this.uuid}_noise, u_${this.uuid}_alpha)`)};
      // *************************************************************************************
  `
    );
  }

  set alpha(v) {
    this.uniforms[`u_${this.uuid}_alpha`].value = v;
  }

  get alpha() {
    return this.uniforms[`u_${this.uuid}_alpha`].value;
  }

  set color(v) {
    this.uniforms[`u_${this.uuid}_color`].value = new three.Color(v);
  }

  get color() {
    return this.uniforms[`u_${this.uuid}_color`].value;
  }

  set scale(v) {
    this.uniforms[`u_${this.uuid}_scale`].value = v;
  }

  get scale() {
    return this.uniforms[`u_${this.uuid}_scale`].value;
  }

}

class Noise$1 extends Abstract {
  constructor(props) {
    super();
    this.name = 'Normals';
    this.mode = 'normal';
    this.uuid = Abstract.genID();
    const {
      alpha,
      mode,
      direction
    } = props || {};
    this.uniforms = {
      [`u_${this.uuid}_alpha`]: {
        value: alpha != null ? alpha : 1
      },
      [`u_${this.uuid}_direction`]: {
        value: direction
      }
    };
    this.mode = BlendModes[mode || 'normal'];
  }

  getVertexVariables() {
    return (
      /* glsl */
      `
    varying vec3 v_${this.uuid}_normals;
    `
    );
  }

  getVertexBody(e) {
    return (
      /* glsl */
      `
    v_${this.uuid}_normals = normal;
    `
    );
  }

  getFragmentVariables() {
    return (
      /* glsl */
      `    
    // SC: Fresnel layer variables **********
    uniform float u_${this.uuid}_alpha;
    uniform vec3 u_${this.uuid}_color;
    uniform vec3 u_${this.uuid}_direction;

    varying vec3 v_${this.uuid}_normals;
    // ************************************
`
    );
  }

  getFragmentBody(e) {
    return (
      /* glsl */
      `    
      // SC: Fresnel layer frag-shader-code ***************************************************
      vec3 f_${this.uuid}_normalColor = vec3(1.);
      f_${this.uuid}_normalColor.x = v_${this.uuid}_normals.x * u_${this.uuid}_direction.x;
      f_${this.uuid}_normalColor.y = v_${this.uuid}_normals.y * u_${this.uuid}_direction.y;
      f_${this.uuid}_normalColor.z = v_${this.uuid}_normals.z * u_${this.uuid}_direction.z;

      ${e} = ${this.getBlendMode(BlendModes[this.mode], e, `vec4(f_${this.uuid}_normalColor, u_${this.uuid}_alpha)`)};
      // *************************************************************************************
  `
    );
  }

  set alpha(v) {
    this.uniforms[`u_${this.uuid}_alpha`].value = v;
  }

  get alpha() {
    return this.uniforms[`u_${this.uuid}_alpha`].value;
  }

  set color(v) {
    this.uniforms[`u_${this.uuid}_color`].value = new three.Color(v);
  }

  get color() {
    return this.uniforms[`u_${this.uuid}_color`].value;
  }

  set direction(v) {
    this.uniforms[`u_${this.uuid}_direction`].value = v;
  }

  get direction() {
    return this.uniforms[`u_${this.uuid}_direction`].value;
  }

}

class Noise extends Abstract {
  constructor(props) {
    super();
    this.name = 'Texture';
    this.mode = 'texture';
    this.uuid = Abstract.genID();
    const {
      alpha,
      mode,
      map
    } = props || {};
    this.uniforms = {
      [`u_${this.uuid}_alpha`]: {
        value: alpha != null ? alpha : 1
      },
      [`u_${this.uuid}_map`]: {
        value: map
      }
    };
    this.mode = BlendModes[mode || 'normal'];
  }

  getVertexVariables() {
    return (
      /* glsl */
      `
    varying vec2 v_${this.uuid}_uv;
    `
    );
  }

  getVertexBody(e) {
    return (
      /* glsl */
      `
    v_${this.uuid}_uv = uv;
    `
    );
  }

  getFragmentVariables() {
    return (
      /* glsl */
      `    
    // SC: Fresnel layer variables **********
    uniform float u_${this.uuid}_alpha;
    uniform sampler2D u_${this.uuid}_map;

    varying vec2 v_${this.uuid}_uv;
    // ************************************
`
    );
  }

  getFragmentBody(e) {
    return (
      /* glsl */
      `    
      // SC: Fresnel layer frag-shader-code ***************************************************
      vec4 f_${this.uuid}_texture = texture2D(u_${this.uuid}_map, v_${this.uuid}_uv);

      ${e} = ${this.getBlendMode(BlendModes[this.mode], e, `vec4(f_${this.uuid}_texture.xyz, f_${this.uuid}_texture.a * u_${this.uuid}_alpha)`)};
      // *************************************************************************************
  `
    );
  }

  set alpha(v) {
    this.uniforms[`u_${this.uuid}_alpha`].value = v;
  }

  get alpha() {
    return this.uniforms[`u_${this.uuid}_alpha`].value;
  }

  set map(v) {
    this.uniforms[`u_${this.uuid}_map`].value = v;
  }

  get map() {
    return this.uniforms[`u_${this.uuid}_map`].value;
  }

}

var HelperChunk = /* glsl */
`
/**
 * Converts a number from one range to another.
 *
 * @name sc_map
 * @function
 * @param {} value      Value to map
 * @param {float} min1  Minimum for current range
 * @param {float} max1  Maximum for current range
 * @param {float} min2  Minimum for wanted range
 * @param {float} max2  Maximum for wanted range
 * @return {float} Mapped Value
 *
 * @example
 * float n = sc_map(-0.2, -1.0, 1.0, 0.0, 1.0);
 * // n = 0.4
 */
float sc_map(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}
`;

var BlendModesChunk = /* glsl */
`
// SC: Blend modes definitions **********

float sc_softLight(float f, float b) {
  return (f < 0.5)
             ? b - (1.0 - 2.0 * f) * b * (1.0 - b)
             : (b < 0.25)
                   ? b + (2.0 * f - 1.0) * b * ((16.0 * b - 12.0) * b + 3.0)
                   : b + (2.0 * f - 1.0) * (sqrt(b) - b);
}

vec4 sc_softLight(vec4 b, vec4 f) {
  vec4 result;
  result.x = sc_softLight(f.x, b.x);
  result.y = sc_softLight(f.y, b.y);
  result.z = sc_softLight(f.z, b.z);
  result.a = sc_softLight(f.a, b.a);
  
  return result;
}

vec4 sc_screen(vec4 f, vec4 b) {
  vec4 result;

  result = 1.0 - (1.0 - f) * (1.0 - b);
  result = mix(f, result, b.a);

  return result;
}

float sc_overlay(float f, float b) {
  return (b < 0.5) ? 2.0 * f * b : 1.0 - 2.0 * (1.0 - f) * (1.0 - b);
}

vec4 sc_overlay(vec4 b, vec4 f) {
  vec4 result;
  result.x = sc_overlay(f.x, b.x);
  result.y = sc_overlay(f.y, b.y);
  result.z = sc_overlay(f.z, b.z);
  result.a = sc_overlay(f.a, b.a);


  return result;
}

vec4 sc_divide(vec4 f, vec4 b) {
  vec4 result = vec4(0.0);
  result = b / f;
  return result;
}

vec4 sc_switch(vec4 f, vec4 b, float o) {
  vec4 result = vec4(0.0);
  result = max((f * o), (b * (1.0 - o)));
  return result;
}

vec4 sc_darken(vec4 f, vec4 b) {
  vec4 result = vec4(0.0);
  result = mix(f, min(f, b), b.a);
  return result;
}

vec4 sc_lighten(vec4 f, vec4 b) {
  vec4 result = vec4(0.0);
  result = mix(f, max(f, b), b.a);
  return result;
}

float sc_addSub(float f, float b) {
  return f > 0.5 ? f + b : b - f;
}
vec4 sc_addSub(vec4 f, vec4 b) {
  vec4 result = vec4(0.0);

  result.r = sc_addSub(f.r, b.r * b.a);
  result.g = sc_addSub(f.g, b.g * b.a);
  result.b = sc_addSub(f.b, b.b* b.a ) ;
  result.a = sc_addSub(f.a, b.a);

  return result;
}

vec4 sc_multiply(vec4 f, vec4 b) {
  vec4 result = vec4(0.0);

  result = mix(f, b * f, b.a);
  result.a = f.a + b.a * (1.0 - f.a);

  return result;
}

vec4 sc_subtract(vec4 f, vec4 b) {
  vec4 result = vec4(0.0);

  result = f - b * b.a;
  result.a = f.a + b.a * (1.0 - f.a);

  return result;
}

vec4 sc_add(vec4 f, vec4 b) {
  vec4 result = vec4(0.0);

  result = f + b * (b.a);
  result.a = f.a + b.a * (1.0 - f.a);

  return result;
}

vec4 sc_copy(vec4 b, vec4 f) {
  vec4 result = vec4(0.0);

  result.a = f.a + b.a * (1.0 - f.a);
  result.rgb = ((f.rgb * f.a) + (b.rgb * b.a) * (1.0 - f.a));

  return result;
}

`; // ************************************

var RandChunk = /* glsl */
`

/**
 * Normalized a value from the range [-1, 1] to the range [0,1].
 *
 * @name sc_normalize
 * @function
 * @param {float} v Value to normalize
 * @return {float} Normalized Value
 *
 * @example
 * float n = sc_normalize(-0.2);
 * // n = 0.4
 */
float sc_normalize(float v) { return sc_map(v, -1.0, 1.0, 0.0, 1.0); }

/**
 * Generates a random 2D Vector.
 *
 * @name sc_rand2
 * @function
 * @param {vec2} p Vector to hash to generate the random numbers from.
 * @return {vec2} Random vector.
 *
 * @example
 * vec2 n = sc_rand2(vec2(1.0, -4.2));
 */
vec2 sc_rand2(vec2 p) {
  return fract(
      sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) *
      43758.5453);
}

/**
 * Generates a random 3D Vector.
 *
 * @name sc_rand3
 * @function
 * @param {vec3} p Vector to hash to generate the random numbers from.
 * @return {vec3} Random vector.
 *
 * @example
 * vec3 n = sc_rand3(vec3(1.0, -4.2, 0.2));
 */
vec3 sc_rand3(vec3 p) { return mod(((p * 34.0) + 1.0) * p, 289.0); }

/**
 * Generates a random 4D Vector.
 *
 * @name sc_rand4
 * @function
 * @param {vec4} p Vector to hash to generate the random numbers from.
 * @return {vec4} Random vector.
 *
 * @example
 * vec4 n = sc_rand4(vec4(1.0, -4.2, 0.2, 2.2));
 */
vec4 sc_rand4(vec4 p) { return mod(((p * 34.0) + 1.0) * p, 289.0); }

/**
 * Generates a random number.
 *
 * @name sc_rand
 * @function
 * @param {float} n Value to hash to generate the number from.
 * @return {float} Random number.
 *
 * @example
 * float n = sc_rand(2.5);
 */
float sc_rand(float n) { return fract(sin(n) * 1e4); }

/**
 * Generates a random number.
 *
 * @name sc_rand
 * @function
 * @param {vec2} p Value to hash to generate the number from.
 * @return {float} Random number.
 *
 * @example
 * float n = sc_rand(vec2(2.5, -1.8));
 */
float sc_rand(vec2 p) {
  return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) *
               (0.1 + abs(sin(p.y * 13.0 + p.x))));
}
`;

class LayerMaterial extends three.ShaderMaterial {
  static constructShader({
    layers,
    ...props
  } = {}) {
    const uniforms = {};
    const variables = {
      vert: '',
      frag: ''
    };
    const body = {
      vert: '',
      frag: ''
    };
    layers == null ? void 0 : layers.forEach(layer => {
      variables.frag += layer.getFragmentVariables() + ' \n';
      variables.vert += layer.getVertexVariables() + ' \n';
      Object.keys(layer.uniforms).forEach(key => uniforms[key] = layer.uniforms[key]);
      body.frag += layer.getFragmentBody('sc_finalColor') + ' \n';
      body.vert += layer.getVertexBody('') + ' \n';
    });
    return {
      uniforms,
      vertexShader: `
    ${variables.vert}
    void main() {
      ${body.vert}
      vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
      gl_Position = projectionMatrix * modelViewPosition;
    }
    `,
      fragmentShader: `
    ${HelperChunk}
    ${RandChunk}
    ${BlendModesChunk}
    ${variables.frag}
    void main() {
      vec4 sc_finalColor = vec4(vec3(1.), 1.);
      ${body.frag}
      gl_FragColor = sc_finalColor;
      #include <tonemapping_fragment>
      #include <encodings_fragment>
      #include <fog_fragment>
      #include <premultiplied_alpha_fragment>
      #include <dithering_fragment>
    }
    `,
      ...props
    };
  }

  constructor(props) {
    super(LayerMaterial.constructShader(props));
    this.uniformsNeedUpdate = true;
    this.needsUpdate = true;
  }

}

exports.Abstract = Abstract;
exports.Base = Base;
exports.Depth = Depth;
exports.Fresnel = Fresnel;
exports.LayerMaterial = LayerMaterial;
exports.Noise = Noise$2;
exports.Normals = Noise$1;
exports.Texture = Noise;
