{"ast":null,"code":"import _regeneratorRuntime from \"/Users/rizzytwizzy/Projects/idxntity/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/rizzytwizzy/Projects/idxntity/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createClass from \"/Users/rizzytwizzy/Projects/idxntity/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/rizzytwizzy/Projects/idxntity/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _assertThisInitialized from \"/Users/rizzytwizzy/Projects/idxntity/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/rizzytwizzy/Projects/idxntity/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/rizzytwizzy/Projects/idxntity/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Vector3, ShaderMaterial, UniformsUtils, UniformsLib, Color, REVISION, LineSegments, Ray, FileLoader, Matrix4, Group, BufferGeometry, BufferAttribute, Mesh, Loader, MeshStandardMaterial, LineBasicMaterial } from \"three\";\nvar FINISH_TYPE_DEFAULT = 0;\nvar FINISH_TYPE_CHROME = 1;\nvar FINISH_TYPE_PEARLESCENT = 2;\nvar FINISH_TYPE_RUBBER = 3;\nvar FINISH_TYPE_MATTE_METALLIC = 4;\nvar FINISH_TYPE_METAL = 5;\nvar FILE_LOCATION_AS_IS = 0;\nvar FILE_LOCATION_TRY_PARTS = 1;\nvar FILE_LOCATION_TRY_P = 2;\nvar FILE_LOCATION_TRY_MODELS = 3;\nvar FILE_LOCATION_TRY_RELATIVE = 4;\nvar FILE_LOCATION_TRY_ABSOLUTE = 5;\nvar FILE_LOCATION_NOT_FOUND = 6;\nvar MAIN_COLOUR_CODE = \"16\";\nvar MAIN_EDGE_COLOUR_CODE = \"24\";\nvar _tempVec0 = /* @__PURE__ */new Vector3();\nvar _tempVec1 = /* @__PURE__ */new Vector3();\nvar LDrawConditionalLineMaterial = /*#__PURE__*/function (_ShaderMaterial) {\n  _inherits(LDrawConditionalLineMaterial, _ShaderMaterial);\n  var _super = _createSuper(LDrawConditionalLineMaterial);\n  function LDrawConditionalLineMaterial(parameters) {\n    var _this;\n    _classCallCheck(this, LDrawConditionalLineMaterial);\n    _this = _super.call(this, {\n      uniforms: UniformsUtils.merge([UniformsLib.fog, {\n        diffuse: {\n          value: new Color()\n        },\n        opacity: {\n          value: 1\n        }\n      }]),\n      vertexShader: /* glsl */\"\\n        attribute vec3 control0;\\n        attribute vec3 control1;\\n        attribute vec3 direction;\\n        varying float discardFlag;\\n\\n        #include <common>\\n        #include <color_pars_vertex>\\n        #include <fog_pars_vertex>\\n        #include <logdepthbuf_pars_vertex>\\n        #include <clipping_planes_pars_vertex>\\n\\n        void main() {\\n          #include <color_vertex>\\n\\n          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\\n          gl_Position = projectionMatrix * mvPosition;\\n\\n          // Transform the line segment ends and control points into camera clip space\\n          vec4 c0 = projectionMatrix * modelViewMatrix * vec4(control0, 1.0);\\n          vec4 c1 = projectionMatrix * modelViewMatrix * vec4(control1, 1.0);\\n          vec4 p0 = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n          vec4 p1 = projectionMatrix * modelViewMatrix * vec4(position + direction, 1.0);\\n\\n          c0.xy /= c0.w;\\n          c1.xy /= c1.w;\\n          p0.xy /= p0.w;\\n          p1.xy /= p1.w;\\n\\n          // Get the direction of the segment and an orthogonal vector\\n          vec2 dir = p1.xy - p0.xy;\\n          vec2 norm = vec2(-dir.y, dir.x);\\n\\n          // Get control point directions from the line\\n          vec2 c0dir = c0.xy - p1.xy;\\n          vec2 c1dir = c1.xy - p1.xy;\\n\\n          // If the vectors to the controls points are pointed in different directions away\\n          // from the line segment then the line should not be drawn.\\n          float d0 = dot(normalize(norm), normalize(c0dir));\\n          float d1 = dot(normalize(norm), normalize(c1dir));\\n          discardFlag = float(sign(d0) != sign(d1));\\n\\n          #include <logdepthbuf_vertex>\\n          #include <clipping_planes_vertex>\\n          #include <fog_vertex>\\n        }\\n      \",\n      fragmentShader: /* glsl */\"\\n        uniform vec3 diffuse;\\n        uniform float opacity;\\n        varying float discardFlag;\\n\\n        #include <common>\\n        #include <color_pars_fragment>\\n        #include <fog_pars_fragment>\\n        #include <logdepthbuf_pars_fragment>\\n        #include <clipping_planes_pars_fragment>\\n\\n        void main() {\\n          if (discardFlag > 0.5) discard;\\n\\n          #include <clipping_planes_fragment>\\n          vec3 outgoingLight = vec3(0.0);\\n          vec4 diffuseColor = vec4(diffuse, opacity);\\n          #include <logdepthbuf_fragment>\\n          #include <color_fragment>\\n          outgoingLight = diffuseColor.rgb; // simple shader\\n          gl_FragColor = vec4(outgoingLight, diffuseColor.a);\\n          #include <tonemapping_fragment>\\n          #include <\".concat(parseInt(REVISION.replace(/\\D+/g, \"\")) >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\", \">\\n          #include <fog_fragment>\\n          #include <premultiplied_alpha_fragment>\\n        }\\n      \")\n    });\n    Object.defineProperties(_assertThisInitialized(_this), {\n      opacity: {\n        get: function get() {\n          return this.uniforms.opacity.value;\n        },\n        set: function set(value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      color: {\n        get: function get() {\n          return this.uniforms.diffuse.value;\n        }\n      }\n    });\n    _this.setValues(parameters);\n    _this.isLDrawConditionalLineMaterial = true;\n    return _this;\n  }\n  return _createClass(LDrawConditionalLineMaterial);\n}(ShaderMaterial);\nvar ConditionalLineSegments = /*#__PURE__*/function (_LineSegments) {\n  _inherits(ConditionalLineSegments, _LineSegments);\n  var _super2 = _createSuper(ConditionalLineSegments);\n  function ConditionalLineSegments(geometry, material) {\n    var _this2;\n    _classCallCheck(this, ConditionalLineSegments);\n    _this2 = _super2.call(this, geometry, material);\n    _this2.isConditionalLine = true;\n    return _this2;\n  }\n  return _createClass(ConditionalLineSegments);\n}(LineSegments);\nfunction generateFaceNormals(faces) {\n  for (var i = 0, l = faces.length; i < l; i++) {\n    var face = faces[i];\n    var vertices = face.vertices;\n    var v0 = vertices[0];\n    var v1 = vertices[1];\n    var v2 = vertices[2];\n    _tempVec0.subVectors(v1, v0);\n    _tempVec1.subVectors(v2, v1);\n    face.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n  }\n}\nvar _ray = /* @__PURE__ */new Ray();\nfunction smoothNormals(faces, lineSegments) {\n  var checkSubSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var hashMultiplier = (1 + 1e-10) * 100;\n  function hashVertex(v) {\n    var x = ~~(v.x * hashMultiplier);\n    var y = ~~(v.y * hashMultiplier);\n    var z = ~~(v.z * hashMultiplier);\n    return \"\".concat(x, \",\").concat(y, \",\").concat(z);\n  }\n  function hashEdge(v0, v1) {\n    return \"\".concat(hashVertex(v0), \"_\").concat(hashVertex(v1));\n  }\n  function toNormalizedRay(v0, v1, targetRay) {\n    targetRay.direction.subVectors(v1, v0).normalize();\n    var scalar = v0.dot(targetRay.direction);\n    targetRay.origin.copy(v0).addScaledVector(targetRay.direction, -scalar);\n    return targetRay;\n  }\n  function hashRay(ray) {\n    return hashEdge(ray.origin, ray.direction);\n  }\n  var hardEdges = /* @__PURE__ */new Set();\n  var hardEdgeRays = /* @__PURE__ */new Map();\n  var halfEdgeList = {};\n  var normals = [];\n  for (var i = 0, l = lineSegments.length; i < l; i++) {\n    var ls = lineSegments[i];\n    var vertices = ls.vertices;\n    var v0 = vertices[0];\n    var v1 = vertices[1];\n    hardEdges.add(hashEdge(v0, v1));\n    hardEdges.add(hashEdge(v1, v0));\n    if (checkSubSegments) {\n      var ray = toNormalizedRay(v0, v1, new Ray());\n      var rh1 = hashRay(ray);\n      if (!hardEdgeRays.has(rh1)) {\n        toNormalizedRay(v1, v0, ray);\n        var rh2 = hashRay(ray);\n        var info2 = {\n          ray: ray,\n          distances: []\n        };\n        hardEdgeRays.set(rh1, info2);\n        hardEdgeRays.set(rh2, info2);\n      }\n      var info = hardEdgeRays.get(rh1);\n      var d0 = info.ray.direction.dot(v0);\n      var d1 = info.ray.direction.dot(v1);\n      if (d0 > d1) {\n        ;\n        var _ref = [d1, d0];\n        d0 = _ref[0];\n        d1 = _ref[1];\n      }\n      info.distances.push(d0, d1);\n    }\n  }\n  for (var _i = 0, _l = faces.length; _i < _l; _i++) {\n    var tri = faces[_i];\n    var _vertices = tri.vertices;\n    var vertCount = _vertices.length;\n    for (var i2 = 0; i2 < vertCount; i2++) {\n      var index = i2;\n      var next = (i2 + 1) % vertCount;\n      var _v = _vertices[index];\n      var _v2 = _vertices[next];\n      var hash = hashEdge(_v, _v2);\n      if (hardEdges.has(hash)) {\n        continue;\n      }\n      if (checkSubSegments) {\n        toNormalizedRay(_v, _v2, _ray);\n        var rayHash = hashRay(_ray);\n        if (hardEdgeRays.has(rayHash)) {\n          var _info = hardEdgeRays.get(rayHash);\n          var _ray2 = _info.ray,\n            distances = _info.distances;\n          var _d = _ray2.direction.dot(_v);\n          var _d2 = _ray2.direction.dot(_v2);\n          if (_d > _d2) {\n            ;\n            var _ref2 = [_d2, _d];\n            _d = _ref2[0];\n            _d2 = _ref2[1];\n          }\n          var found = false;\n          for (var i3 = 0, l2 = distances.length; i3 < l2; i3 += 2) {\n            if (_d >= distances[i3] && _d2 <= distances[i3 + 1]) {\n              found = true;\n              break;\n            }\n          }\n          if (found) {\n            continue;\n          }\n        }\n      }\n      var _info2 = {\n        index: index,\n        tri: tri\n      };\n      halfEdgeList[hash] = _info2;\n    }\n  }\n  while (true) {\n    var halfEdge = null;\n    for (var key in halfEdgeList) {\n      halfEdge = halfEdgeList[key];\n      break;\n    }\n    if (halfEdge === null) {\n      break;\n    }\n    var queue = [halfEdge];\n    while (queue.length > 0) {\n      var _tri = queue.pop().tri;\n      var _vertices2 = _tri.vertices;\n      var vertNormals = _tri.normals;\n      var faceNormal = _tri.faceNormal;\n      var _vertCount = _vertices2.length;\n      for (var _i2 = 0; _i2 < _vertCount; _i2++) {\n        var _index = _i2;\n        var _next = (_i2 + 1) % _vertCount;\n        var _v3 = _vertices2[_index];\n        var _v4 = _vertices2[_next];\n        var _hash = hashEdge(_v3, _v4);\n        delete halfEdgeList[_hash];\n        var reverseHash = hashEdge(_v4, _v3);\n        var otherInfo = halfEdgeList[reverseHash];\n        if (otherInfo) {\n          var otherTri = otherInfo.tri;\n          var otherIndex = otherInfo.index;\n          var otherNormals = otherTri.normals;\n          var otherVertCount = otherNormals.length;\n          var otherFaceNormal = otherTri.faceNormal;\n          if (Math.abs(otherTri.faceNormal.dot(_tri.faceNormal)) < 0.25) {\n            continue;\n          }\n          if (reverseHash in halfEdgeList) {\n            queue.push(otherInfo);\n            delete halfEdgeList[reverseHash];\n          }\n          var otherNext = (otherIndex + 1) % otherVertCount;\n          if (vertNormals[_index] && otherNormals[otherNext] && vertNormals[_index] !== otherNormals[otherNext]) {\n            otherNormals[otherNext].norm.add(vertNormals[_index].norm);\n            vertNormals[_index].norm = otherNormals[otherNext].norm;\n          }\n          var sharedNormal1 = vertNormals[_index] || otherNormals[otherNext];\n          if (sharedNormal1 === null) {\n            sharedNormal1 = {\n              norm: new Vector3()\n            };\n            normals.push(sharedNormal1.norm);\n          }\n          if (vertNormals[_index] === null) {\n            vertNormals[_index] = sharedNormal1;\n            sharedNormal1.norm.add(faceNormal);\n          }\n          if (otherNormals[otherNext] === null) {\n            otherNormals[otherNext] = sharedNormal1;\n            sharedNormal1.norm.add(otherFaceNormal);\n          }\n          if (vertNormals[_next] && otherNormals[otherIndex] && vertNormals[_next] !== otherNormals[otherIndex]) {\n            otherNormals[otherIndex].norm.add(vertNormals[_next].norm);\n            vertNormals[_next].norm = otherNormals[otherIndex].norm;\n          }\n          var sharedNormal2 = vertNormals[_next] || otherNormals[otherIndex];\n          if (sharedNormal2 === null) {\n            sharedNormal2 = {\n              norm: new Vector3()\n            };\n            normals.push(sharedNormal2.norm);\n          }\n          if (vertNormals[_next] === null) {\n            vertNormals[_next] = sharedNormal2;\n            sharedNormal2.norm.add(faceNormal);\n          }\n          if (otherNormals[otherIndex] === null) {\n            otherNormals[otherIndex] = sharedNormal2;\n            sharedNormal2.norm.add(otherFaceNormal);\n          }\n        }\n      }\n    }\n  }\n  for (var _i3 = 0, _l2 = normals.length; _i3 < _l2; _i3++) {\n    normals[_i3].normalize();\n  }\n}\nfunction isPartType(type) {\n  return type === \"Part\" || type === \"Unofficial_Part\";\n}\nfunction isPrimitiveType(type) {\n  return /primitive/i.test(type) || type === \"Subpart\";\n}\nvar LineParser = /*#__PURE__*/function () {\n  function LineParser(line, lineNumber) {\n    _classCallCheck(this, LineParser);\n    this.line = line;\n    this.lineLength = line.length;\n    this.currentCharIndex = 0;\n    this.currentChar = \" \";\n    this.lineNumber = lineNumber;\n  }\n  _createClass(LineParser, [{\n    key: \"seekNonSpace\",\n    value: function seekNonSpace() {\n      while (this.currentCharIndex < this.lineLength) {\n        this.currentChar = this.line.charAt(this.currentCharIndex);\n        if (this.currentChar !== \" \" && this.currentChar !== \"\t\") {\n          return;\n        }\n        this.currentCharIndex++;\n      }\n    }\n  }, {\n    key: \"getToken\",\n    value: function getToken() {\n      var pos0 = this.currentCharIndex++;\n      while (this.currentCharIndex < this.lineLength) {\n        this.currentChar = this.line.charAt(this.currentCharIndex);\n        if (this.currentChar === \" \" || this.currentChar === \"\t\") {\n          break;\n        }\n        this.currentCharIndex++;\n      }\n      var pos1 = this.currentCharIndex;\n      this.seekNonSpace();\n      return this.line.substring(pos0, pos1);\n    }\n  }, {\n    key: \"getVector\",\n    value: function getVector() {\n      return new Vector3(parseFloat(this.getToken()), parseFloat(this.getToken()), parseFloat(this.getToken()));\n    }\n  }, {\n    key: \"getRemainingString\",\n    value: function getRemainingString() {\n      return this.line.substring(this.currentCharIndex, this.lineLength);\n    }\n  }, {\n    key: \"isAtTheEnd\",\n    value: function isAtTheEnd() {\n      return this.currentCharIndex >= this.lineLength;\n    }\n  }, {\n    key: \"setToEnd\",\n    value: function setToEnd() {\n      this.currentCharIndex = this.lineLength;\n    }\n  }, {\n    key: \"getLineNumberString\",\n    value: function getLineNumberString() {\n      return this.lineNumber >= 0 ? \" at line \" + this.lineNumber : \"\";\n    }\n  }]);\n  return LineParser;\n}();\nvar LDrawParsedCache = /*#__PURE__*/function () {\n  function LDrawParsedCache(loader) {\n    _classCallCheck(this, LDrawParsedCache);\n    this.loader = loader;\n    this._cache = {};\n  }\n  _createClass(LDrawParsedCache, [{\n    key: \"cloneResult\",\n    value: function cloneResult(original) {\n      var result = {};\n      result.faces = original.faces.map(function (face) {\n        return {\n          colorCode: face.colorCode,\n          material: face.material,\n          vertices: face.vertices.map(function (v) {\n            return v.clone();\n          }),\n          normals: face.normals.map(function () {\n            return null;\n          }),\n          faceNormal: null\n        };\n      });\n      result.conditionalSegments = original.conditionalSegments.map(function (face) {\n        return {\n          colorCode: face.colorCode,\n          material: face.material,\n          vertices: face.vertices.map(function (v) {\n            return v.clone();\n          }),\n          controlPoints: face.controlPoints.map(function (v) {\n            return v.clone();\n          })\n        };\n      });\n      result.lineSegments = original.lineSegments.map(function (face) {\n        return {\n          colorCode: face.colorCode,\n          material: face.material,\n          vertices: face.vertices.map(function (v) {\n            return v.clone();\n          })\n        };\n      });\n      result.type = original.type;\n      result.category = original.category;\n      result.keywords = original.keywords;\n      result.subobjects = original.subobjects;\n      result.totalFaces = original.totalFaces;\n      result.startingConstructionStep = original.startingConstructionStep;\n      result.materials = original.materials;\n      result.group = null;\n      return result;\n    }\n  }, {\n    key: \"fetchData\",\n    value: function () {\n      var _fetchData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(fileName) {\n        var triedLowerCase, locationState, subobjectURL, loader, fileLoader, text;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              triedLowerCase = false;\n              locationState = FILE_LOCATION_AS_IS;\n            case 2:\n              if (!(locationState !== FILE_LOCATION_NOT_FOUND)) {\n                _context.next = 40;\n                break;\n              }\n              subobjectURL = fileName;\n              _context.t0 = locationState;\n              _context.next = _context.t0 === FILE_LOCATION_AS_IS ? 7 : _context.t0 === FILE_LOCATION_TRY_PARTS ? 9 : _context.t0 === FILE_LOCATION_TRY_P ? 12 : _context.t0 === FILE_LOCATION_TRY_MODELS ? 15 : _context.t0 === FILE_LOCATION_TRY_RELATIVE ? 18 : _context.t0 === FILE_LOCATION_TRY_ABSOLUTE ? 21 : 23;\n              break;\n            case 7:\n              locationState = locationState + 1;\n              return _context.abrupt(\"break\", 23);\n            case 9:\n              subobjectURL = \"parts/\" + subobjectURL;\n              locationState = locationState + 1;\n              return _context.abrupt(\"break\", 23);\n            case 12:\n              subobjectURL = \"p/\" + subobjectURL;\n              locationState = locationState + 1;\n              return _context.abrupt(\"break\", 23);\n            case 15:\n              subobjectURL = \"models/\" + subobjectURL;\n              locationState = locationState + 1;\n              return _context.abrupt(\"break\", 23);\n            case 18:\n              subobjectURL = fileName.substring(0, fileName.lastIndexOf(\"/\") + 1) + subobjectURL;\n              locationState = locationState + 1;\n              return _context.abrupt(\"break\", 23);\n            case 21:\n              if (triedLowerCase) {\n                locationState = FILE_LOCATION_NOT_FOUND;\n              } else {\n                fileName = fileName.toLowerCase();\n                subobjectURL = fileName;\n                triedLowerCase = true;\n                locationState = FILE_LOCATION_AS_IS;\n              }\n              return _context.abrupt(\"break\", 23);\n            case 23:\n              loader = this.loader;\n              fileLoader = new FileLoader(loader.manager);\n              fileLoader.setPath(loader.partsLibraryPath);\n              fileLoader.setRequestHeader(loader.requestHeader);\n              fileLoader.setWithCredentials(loader.withCredentials);\n              _context.prev = 28;\n              _context.next = 31;\n              return fileLoader.loadAsync(subobjectURL);\n            case 31:\n              text = _context.sent;\n              return _context.abrupt(\"return\", text);\n            case 35:\n              _context.prev = 35;\n              _context.t1 = _context[\"catch\"](28);\n              return _context.abrupt(\"continue\", 2);\n            case 38:\n              _context.next = 2;\n              break;\n            case 40:\n              throw new Error('LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.');\n            case 41:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[28, 35]]);\n      }));\n      function fetchData(_x) {\n        return _fetchData.apply(this, arguments);\n      }\n      return fetchData;\n    }()\n  }, {\n    key: \"parse\",\n    value: function parse(text) {\n      var fileName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var loader = this.loader;\n      var faces = [];\n      var lineSegments = [];\n      var conditionalSegments = [];\n      var subobjects = [];\n      var materials = {};\n      var getLocalMaterial = function getLocalMaterial(colorCode) {\n        return materials[colorCode] || null;\n      };\n      var type = \"Model\";\n      var category = null;\n      var keywords = null;\n      var totalFaces = 0;\n      if (text.indexOf(\"\\r\\n\") !== -1) {\n        text = text.replace(/\\r\\n/g, \"\\n\");\n      }\n      var lines = text.split(\"\\n\");\n      var numLines = lines.length;\n      var parsingEmbeddedFiles = false;\n      var currentEmbeddedFileName = null;\n      var currentEmbeddedText = null;\n      var bfcCertified = false;\n      var bfcCCW = true;\n      var bfcInverted = false;\n      var bfcCull = true;\n      var startingConstructionStep = false;\n      for (var lineIndex = 0; lineIndex < numLines; lineIndex++) {\n        var line = lines[lineIndex];\n        if (line.length === 0) continue;\n        if (parsingEmbeddedFiles) {\n          if (line.startsWith(\"0 FILE \")) {\n            this.setData(currentEmbeddedFileName, currentEmbeddedText);\n            currentEmbeddedFileName = line.substring(7);\n            currentEmbeddedText = \"\";\n          } else {\n            currentEmbeddedText += line + \"\\n\";\n          }\n          continue;\n        }\n        var lp = new LineParser(line, lineIndex + 1);\n        lp.seekNonSpace();\n        if (lp.isAtTheEnd()) {\n          continue;\n        }\n        var lineType = lp.getToken();\n        var material = void 0;\n        var colorCode = void 0;\n        var segment = void 0;\n        var ccw = void 0;\n        var doubleSided = void 0;\n        var v0 = void 0,\n          v1 = void 0,\n          v2 = void 0,\n          v3 = void 0,\n          c0 = void 0,\n          c1 = void 0;\n        switch (lineType) {\n          case \"0\":\n            var meta = lp.getToken();\n            if (meta) {\n              switch (meta) {\n                case \"!LDRAW_ORG\":\n                  type = lp.getToken();\n                  break;\n                case \"!COLOUR\":\n                  material = loader.parseColorMetaDirective(lp);\n                  if (material) {\n                    materials[material.userData.code] = material;\n                  } else {\n                    console.warn(\"LDrawLoader: Error parsing material\" + lp.getLineNumberString());\n                  }\n                  break;\n                case \"!CATEGORY\":\n                  category = lp.getToken();\n                  break;\n                case \"!KEYWORDS\":\n                  var newKeywords = lp.getRemainingString().split(\",\");\n                  if (newKeywords.length > 0) {\n                    if (!keywords) {\n                      keywords = [];\n                    }\n                    newKeywords.forEach(function (keyword) {\n                      keywords.push(keyword.trim());\n                    });\n                  }\n                  break;\n                case \"FILE\":\n                  if (lineIndex > 0) {\n                    parsingEmbeddedFiles = true;\n                    currentEmbeddedFileName = lp.getRemainingString();\n                    currentEmbeddedText = \"\";\n                    bfcCertified = false;\n                    bfcCCW = true;\n                  }\n                  break;\n                case \"BFC\":\n                  while (!lp.isAtTheEnd()) {\n                    var token = lp.getToken();\n                    switch (token) {\n                      case \"CERTIFY\":\n                      case \"NOCERTIFY\":\n                        bfcCertified = token === \"CERTIFY\";\n                        bfcCCW = true;\n                        break;\n                      case \"CW\":\n                      case \"CCW\":\n                        bfcCCW = token === \"CCW\";\n                        break;\n                      case \"INVERTNEXT\":\n                        bfcInverted = true;\n                        break;\n                      case \"CLIP\":\n                      case \"NOCLIP\":\n                        bfcCull = token === \"CLIP\";\n                        break;\n                      default:\n                        console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                        break;\n                    }\n                  }\n                  break;\n                case \"STEP\":\n                  startingConstructionStep = true;\n                  break;\n                default:\n                  break;\n              }\n            }\n            break;\n          case \"1\":\n            colorCode = lp.getToken();\n            material = getLocalMaterial(colorCode);\n            var posX = parseFloat(lp.getToken());\n            var posY = parseFloat(lp.getToken());\n            var posZ = parseFloat(lp.getToken());\n            var m0 = parseFloat(lp.getToken());\n            var m1 = parseFloat(lp.getToken());\n            var m2 = parseFloat(lp.getToken());\n            var m3 = parseFloat(lp.getToken());\n            var m4 = parseFloat(lp.getToken());\n            var m5 = parseFloat(lp.getToken());\n            var m6 = parseFloat(lp.getToken());\n            var m7 = parseFloat(lp.getToken());\n            var m8 = parseFloat(lp.getToken());\n            var matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n            var fileName2 = lp.getRemainingString().trim().replace(/\\\\/g, \"/\");\n            if (loader.fileMap[fileName2]) {\n              fileName2 = loader.fileMap[fileName2];\n            } else {\n              if (fileName2.startsWith(\"s/\")) {\n                fileName2 = \"parts/\" + fileName2;\n              } else if (fileName2.startsWith(\"48/\")) {\n                fileName2 = \"p/\" + fileName2;\n              }\n            }\n            subobjects.push({\n              material: material,\n              colorCode: colorCode,\n              matrix: matrix,\n              fileName: fileName2,\n              inverted: bfcInverted,\n              startingConstructionStep: startingConstructionStep\n            });\n            bfcInverted = false;\n            break;\n          case \"2\":\n            colorCode = lp.getToken();\n            material = getLocalMaterial(colorCode);\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            segment = {\n              material: material,\n              colorCode: colorCode,\n              vertices: [v0, v1]\n            };\n            lineSegments.push(segment);\n            break;\n          case \"5\":\n            colorCode = lp.getToken();\n            material = getLocalMaterial(colorCode);\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            c0 = lp.getVector();\n            c1 = lp.getVector();\n            segment = {\n              material: material,\n              colorCode: colorCode,\n              vertices: [v0, v1],\n              controlPoints: [c0, c1]\n            };\n            conditionalSegments.push(segment);\n            break;\n          case \"3\":\n            colorCode = lp.getToken();\n            material = getLocalMaterial(colorCode);\n            ccw = bfcCCW;\n            doubleSided = !bfcCertified || !bfcCull;\n            if (ccw === true) {\n              v0 = lp.getVector();\n              v1 = lp.getVector();\n              v2 = lp.getVector();\n            } else {\n              v2 = lp.getVector();\n              v1 = lp.getVector();\n              v0 = lp.getVector();\n            }\n            faces.push({\n              material: material,\n              colorCode: colorCode,\n              faceNormal: null,\n              vertices: [v0, v1, v2],\n              normals: [null, null, null]\n            });\n            totalFaces++;\n            if (doubleSided === true) {\n              faces.push({\n                material: material,\n                colorCode: colorCode,\n                faceNormal: null,\n                vertices: [v2, v1, v0],\n                normals: [null, null, null]\n              });\n              totalFaces++;\n            }\n            break;\n          case \"4\":\n            colorCode = lp.getToken();\n            material = getLocalMaterial(colorCode);\n            ccw = bfcCCW;\n            doubleSided = !bfcCertified || !bfcCull;\n            if (ccw === true) {\n              v0 = lp.getVector();\n              v1 = lp.getVector();\n              v2 = lp.getVector();\n              v3 = lp.getVector();\n            } else {\n              v3 = lp.getVector();\n              v2 = lp.getVector();\n              v1 = lp.getVector();\n              v0 = lp.getVector();\n            }\n            faces.push({\n              material: material,\n              colorCode: colorCode,\n              faceNormal: null,\n              vertices: [v0, v1, v2, v3],\n              normals: [null, null, null, null]\n            });\n            totalFaces += 2;\n            if (doubleSided === true) {\n              faces.push({\n                material: material,\n                colorCode: colorCode,\n                faceNormal: null,\n                vertices: [v3, v2, v1, v0],\n                normals: [null, null, null, null]\n              });\n              totalFaces += 2;\n            }\n            break;\n          default:\n            throw new Error('LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + \".\");\n        }\n      }\n      if (parsingEmbeddedFiles) {\n        this.setData(currentEmbeddedFileName, currentEmbeddedText);\n      }\n      return {\n        faces: faces,\n        conditionalSegments: conditionalSegments,\n        lineSegments: lineSegments,\n        type: type,\n        category: category,\n        keywords: keywords,\n        subobjects: subobjects,\n        totalFaces: totalFaces,\n        startingConstructionStep: startingConstructionStep,\n        materials: materials,\n        fileName: fileName,\n        group: null\n      };\n    }\n    // returns an (optionally cloned) instance of the data\n  }, {\n    key: \"getData\",\n    value: function getData(fileName) {\n      var clone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var key = fileName.toLowerCase();\n      var result = this._cache[key];\n      if (result === null || result instanceof Promise) {\n        return null;\n      }\n      if (clone) {\n        return this.cloneResult(result);\n      } else {\n        return result;\n      }\n    }\n    // kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n    // the data is ready to use and can be retrieved synchronously with \"getData\".\n  }, {\n    key: \"ensureDataLoaded\",\n    value: function () {\n      var _ensureDataLoaded = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(fileName) {\n        var _this3 = this;\n        var key;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              key = fileName.toLowerCase();\n              if (!(key in this._cache)) {\n                this._cache[key] = this.fetchData(fileName).then(function (text) {\n                  var info = _this3.parse(text, fileName);\n                  _this3._cache[key] = info;\n                  return info;\n                });\n              }\n              _context2.next = 4;\n              return this._cache[key];\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function ensureDataLoaded(_x2) {\n        return _ensureDataLoaded.apply(this, arguments);\n      }\n      return ensureDataLoaded;\n    }() // sets the data in the cache from parsed data\n  }, {\n    key: \"setData\",\n    value: function setData(fileName, text) {\n      var key = fileName.toLowerCase();\n      this._cache[key] = this.parse(text, fileName);\n    }\n  }]);\n  return LDrawParsedCache;\n}();\nfunction getMaterialFromCode(colorCode, parentColorCode, materialHierarchy, forEdge) {\n  var isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n  if (isPassthrough) {\n    colorCode = parentColorCode;\n  }\n  return materialHierarchy[colorCode] || null;\n}\nvar LDrawPartsGeometryCache = /*#__PURE__*/function () {\n  function LDrawPartsGeometryCache(loader) {\n    _classCallCheck(this, LDrawPartsGeometryCache);\n    this.loader = loader;\n    this.parseCache = new LDrawParsedCache(loader);\n    this._cache = {};\n  }\n  // Convert the given file information into a mesh by processing subobjects.\n  _createClass(LDrawPartsGeometryCache, [{\n    key: \"processIntoMesh\",\n    value: function () {\n      var _processIntoMesh = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(info) {\n        var _this4 = this;\n        var loader, parseCache, faceMaterials, processInfoSubobjects, i, l, checkSubSegments, group;\n        return _regeneratorRuntime().wrap(function _callee4$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              loader = this.loader;\n              parseCache = this.parseCache;\n              faceMaterials = /* @__PURE__ */new Set();\n              processInfoSubobjects = /*#__PURE__*/function () {\n                var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(info2) {\n                  var subobject,\n                    subobjects,\n                    promises,\n                    _loop,\n                    i,\n                    l,\n                    group2,\n                    subobjectInfos,\n                    _i4,\n                    _l3,\n                    subobject2,\n                    subobjectInfo,\n                    subobjectGroup,\n                    parentLineSegments,\n                    parentConditionalSegments,\n                    parentFaces,\n                    lineSegments,\n                    conditionalSegments,\n                    faces,\n                    matrix,\n                    inverted,\n                    matrixScaleInverted,\n                    colorCode,\n                    lineColorCode,\n                    i2,\n                    l2,\n                    ls,\n                    vertices,\n                    _i5,\n                    _l4,\n                    os,\n                    _vertices3,\n                    controlPoints,\n                    _i6,\n                    _l5,\n                    tri,\n                    _vertices4,\n                    i3,\n                    l3,\n                    _args4 = arguments;\n                  return _regeneratorRuntime().wrap(function _callee3$(_context4) {\n                    while (1) switch (_context4.prev = _context4.next) {\n                      case 0:\n                        subobject = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : null;\n                        subobjects = info2.subobjects;\n                        promises = [];\n                        _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n                          var subobject2, promise;\n                          return _regeneratorRuntime().wrap(function _loop$(_context3) {\n                            while (1) switch (_context3.prev = _context3.next) {\n                              case 0:\n                                subobject2 = subobjects[i];\n                                promise = parseCache.ensureDataLoaded(subobject2.fileName).then(function () {\n                                  var subobjectInfo = parseCache.getData(subobject2.fileName, false);\n                                  if (!isPrimitiveType(subobjectInfo.type)) {\n                                    return _this4.loadModel(subobject2.fileName).catch(function (error) {\n                                      console.warn(error);\n                                      return null;\n                                    });\n                                  }\n                                  return processInfoSubobjects(parseCache.getData(subobject2.fileName), subobject2);\n                                });\n                                promises.push(promise);\n                              case 3:\n                              case \"end\":\n                                return _context3.stop();\n                            }\n                          }, _loop);\n                        });\n                        i = 0, l = subobjects.length;\n                      case 5:\n                        if (!(i < l)) {\n                          _context4.next = 10;\n                          break;\n                        }\n                        return _context4.delegateYield(_loop(), \"t0\", 7);\n                      case 7:\n                        i++;\n                        _context4.next = 5;\n                        break;\n                      case 10:\n                        group2 = new Group();\n                        group2.userData.category = info2.category;\n                        group2.userData.keywords = info2.keywords;\n                        info2.group = group2;\n                        _context4.next = 16;\n                        return Promise.all(promises);\n                      case 16:\n                        subobjectInfos = _context4.sent;\n                        _i4 = 0, _l3 = subobjectInfos.length;\n                      case 18:\n                        if (!(_i4 < _l3)) {\n                          _context4.next = 50;\n                          break;\n                        }\n                        subobject2 = info2.subobjects[_i4];\n                        subobjectInfo = subobjectInfos[_i4];\n                        if (!(subobjectInfo === null)) {\n                          _context4.next = 23;\n                          break;\n                        }\n                        return _context4.abrupt(\"continue\", 47);\n                      case 23:\n                        if (!subobjectInfo.isGroup) {\n                          _context4.next = 31;\n                          break;\n                        }\n                        subobjectGroup = subobjectInfo;\n                        subobject2.matrix.decompose(subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale);\n                        subobjectGroup.userData.startingConstructionStep = subobject2.startingConstructionStep;\n                        subobjectGroup.name = subobject2.fileName;\n                        loader.applyMaterialsToMesh(subobjectGroup, subobject2.colorCode, info2.materials);\n                        group2.add(subobjectGroup);\n                        return _context4.abrupt(\"continue\", 47);\n                      case 31:\n                        if (subobjectInfo.group.children.length) {\n                          group2.add(subobjectInfo.group);\n                        }\n                        parentLineSegments = info2.lineSegments;\n                        parentConditionalSegments = info2.conditionalSegments;\n                        parentFaces = info2.faces;\n                        lineSegments = subobjectInfo.lineSegments;\n                        conditionalSegments = subobjectInfo.conditionalSegments;\n                        faces = subobjectInfo.faces;\n                        matrix = subobject2.matrix;\n                        inverted = subobject2.inverted;\n                        matrixScaleInverted = matrix.determinant() < 0;\n                        colorCode = subobject2.colorCode;\n                        lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;\n                        for (i2 = 0, l2 = lineSegments.length; i2 < l2; i2++) {\n                          ls = lineSegments[i2];\n                          vertices = ls.vertices;\n                          vertices[0].applyMatrix4(matrix);\n                          vertices[1].applyMatrix4(matrix);\n                          ls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;\n                          ls.material = ls.material || getMaterialFromCode(ls.colorCode, ls.colorCode, info2.materials, true);\n                          parentLineSegments.push(ls);\n                        }\n                        for (_i5 = 0, _l4 = conditionalSegments.length; _i5 < _l4; _i5++) {\n                          os = conditionalSegments[_i5];\n                          _vertices3 = os.vertices;\n                          controlPoints = os.controlPoints;\n                          _vertices3[0].applyMatrix4(matrix);\n                          _vertices3[1].applyMatrix4(matrix);\n                          controlPoints[0].applyMatrix4(matrix);\n                          controlPoints[1].applyMatrix4(matrix);\n                          os.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;\n                          os.material = os.material || getMaterialFromCode(os.colorCode, os.colorCode, info2.materials, true);\n                          parentConditionalSegments.push(os);\n                        }\n                        for (_i6 = 0, _l5 = faces.length; _i6 < _l5; _i6++) {\n                          tri = faces[_i6];\n                          _vertices4 = tri.vertices;\n                          for (i3 = 0, l3 = _vertices4.length; i3 < l3; i3++) {\n                            _vertices4[i3].applyMatrix4(matrix);\n                          }\n                          tri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;\n                          tri.material = tri.material || getMaterialFromCode(tri.colorCode, colorCode, info2.materials, false);\n                          faceMaterials.add(tri.colorCode);\n                          if (matrixScaleInverted !== inverted) {\n                            _vertices4.reverse();\n                          }\n                          parentFaces.push(tri);\n                        }\n                        info2.totalFaces += subobjectInfo.totalFaces;\n                      case 47:\n                        _i4++;\n                        _context4.next = 18;\n                        break;\n                      case 50:\n                        if (subobject) {\n                          loader.applyMaterialsToMesh(group2, subobject.colorCode, info2.materials);\n                        }\n                        return _context4.abrupt(\"return\", info2);\n                      case 52:\n                      case \"end\":\n                        return _context4.stop();\n                    }\n                  }, _callee3);\n                }));\n                return function processInfoSubobjects(_x4) {\n                  return _ref3.apply(this, arguments);\n                };\n              }();\n              for (i = 0, l = info.faces; i < l; i++) {\n                faceMaterials.add(info.faces[i].colorCode);\n              }\n              _context5.next = 7;\n              return processInfoSubobjects(info);\n            case 7:\n              if (loader.smoothNormals) {\n                checkSubSegments = faceMaterials.size > 1;\n                generateFaceNormals(info.faces);\n                smoothNormals(info.faces, info.lineSegments, checkSubSegments);\n              }\n              group = info.group;\n              if (info.faces.length > 0) {\n                group.add(createObject(info.faces, 3, false, info.totalFaces));\n              }\n              if (info.lineSegments.length > 0) {\n                group.add(createObject(info.lineSegments, 2));\n              }\n              if (info.conditionalSegments.length > 0) {\n                group.add(createObject(info.conditionalSegments, 2, true));\n              }\n              return _context5.abrupt(\"return\", group);\n            case 13:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee4, this);\n      }));\n      function processIntoMesh(_x3) {\n        return _processIntoMesh.apply(this, arguments);\n      }\n      return processIntoMesh;\n    }()\n  }, {\n    key: \"hasCachedModel\",\n    value: function hasCachedModel(fileName) {\n      return fileName !== null && fileName.toLowerCase() in this._cache;\n    }\n  }, {\n    key: \"getCachedModel\",\n    value: function () {\n      var _getCachedModel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(fileName) {\n        var key, group;\n        return _regeneratorRuntime().wrap(function _callee5$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              if (!(fileName !== null && this.hasCachedModel(fileName))) {\n                _context6.next = 8;\n                break;\n              }\n              key = fileName.toLowerCase();\n              _context6.next = 4;\n              return this._cache[key];\n            case 4:\n              group = _context6.sent;\n              return _context6.abrupt(\"return\", group.clone());\n            case 8:\n              return _context6.abrupt(\"return\", null);\n            case 9:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee5, this);\n      }));\n      function getCachedModel(_x5) {\n        return _getCachedModel.apply(this, arguments);\n      }\n      return getCachedModel;\n    }() // Loads and parses the model with the given file name. Returns a cached copy if available.\n  }, {\n    key: \"loadModel\",\n    value: function () {\n      var _loadModel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(fileName) {\n        var parseCache, key, info, promise, group;\n        return _regeneratorRuntime().wrap(function _callee6$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              parseCache = this.parseCache;\n              key = fileName.toLowerCase();\n              if (!this.hasCachedModel(fileName)) {\n                _context7.next = 6;\n                break;\n              }\n              return _context7.abrupt(\"return\", this.getCachedModel(fileName));\n            case 6:\n              _context7.next = 8;\n              return parseCache.ensureDataLoaded(fileName);\n            case 8:\n              info = parseCache.getData(fileName);\n              promise = this.processIntoMesh(info);\n              if (!this.hasCachedModel(fileName)) {\n                _context7.next = 12;\n                break;\n              }\n              return _context7.abrupt(\"return\", this.getCachedModel(fileName));\n            case 12:\n              if (isPartType(info.type)) {\n                this._cache[key] = promise;\n              }\n              _context7.next = 15;\n              return promise;\n            case 15:\n              group = _context7.sent;\n              return _context7.abrupt(\"return\", group.clone());\n            case 17:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee6, this);\n      }));\n      function loadModel(_x6) {\n        return _loadModel.apply(this, arguments);\n      }\n      return loadModel;\n    }() // parses the given model text into a renderable object. Returns cached copy if available.\n  }, {\n    key: \"parseModel\",\n    value: function () {\n      var _parseModel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(text) {\n        var parseCache, info;\n        return _regeneratorRuntime().wrap(function _callee7$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              parseCache = this.parseCache;\n              info = parseCache.parse(text);\n              if (!(isPartType(info.type) && this.hasCachedModel(info.fileName))) {\n                _context8.next = 4;\n                break;\n              }\n              return _context8.abrupt(\"return\", this.getCachedModel(info.fileName));\n            case 4:\n              return _context8.abrupt(\"return\", this.processIntoMesh(info));\n            case 5:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee7, this);\n      }));\n      function parseModel(_x7) {\n        return _parseModel.apply(this, arguments);\n      }\n      return parseModel;\n    }()\n  }]);\n  return LDrawPartsGeometryCache;\n}();\nfunction sortByMaterial(a, b) {\n  if (a.colorCode === b.colorCode) {\n    return 0;\n  }\n  if (a.colorCode < b.colorCode) {\n    return -1;\n  }\n  return 1;\n}\nfunction createObject(elements, elementSize) {\n  var isConditionalSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var totalElements = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  elements.sort(sortByMaterial);\n  if (totalElements === null) {\n    totalElements = elements.length;\n  }\n  var positions = new Float32Array(elementSize * totalElements * 3);\n  var normals = elementSize === 3 ? new Float32Array(elementSize * totalElements * 3) : null;\n  var materials = [];\n  var quadArray = new Array(6);\n  var bufferGeometry = new BufferGeometry();\n  var prevMaterial = null;\n  var index0 = 0;\n  var numGroupVerts = 0;\n  var offset = 0;\n  for (var iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n    var elem = elements[iElem];\n    var vertices = elem.vertices;\n    if (vertices.length === 4) {\n      quadArray[0] = vertices[0];\n      quadArray[1] = vertices[1];\n      quadArray[2] = vertices[2];\n      quadArray[3] = vertices[0];\n      quadArray[4] = vertices[2];\n      quadArray[5] = vertices[3];\n      vertices = quadArray;\n    }\n    for (var j = 0, l = vertices.length; j < l; j++) {\n      var v = vertices[j];\n      var index = offset + j * 3;\n      positions[index + 0] = v.x;\n      positions[index + 1] = v.y;\n      positions[index + 2] = v.z;\n    }\n    if (elementSize === 3) {\n      if (!elem.faceNormal) {\n        var v0 = vertices[0];\n        var v1 = vertices[1];\n        var v2 = vertices[2];\n        _tempVec0.subVectors(v1, v0);\n        _tempVec1.subVectors(v2, v1);\n        elem.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n      }\n      var elemNormals = elem.normals;\n      if (elemNormals.length === 4) {\n        quadArray[0] = elemNormals[0];\n        quadArray[1] = elemNormals[1];\n        quadArray[2] = elemNormals[2];\n        quadArray[3] = elemNormals[0];\n        quadArray[4] = elemNormals[2];\n        quadArray[5] = elemNormals[3];\n        elemNormals = quadArray;\n      }\n      for (var _j = 0, _l6 = elemNormals.length; _j < _l6; _j++) {\n        var n = elem.faceNormal;\n        if (elemNormals[_j]) {\n          n = elemNormals[_j].norm;\n        }\n        var _index2 = offset + _j * 3;\n        normals[_index2 + 0] = n.x;\n        normals[_index2 + 1] = n.y;\n        normals[_index2 + 2] = n.z;\n      }\n    }\n    if (prevMaterial !== elem.colorCode) {\n      if (prevMaterial !== null) {\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n      }\n      var material = elem.material;\n      if (material !== null) {\n        if (elementSize === 3) {\n          materials.push(material);\n        } else if (elementSize === 2) {\n          if (material !== null) {\n            if (isConditionalSegments) {\n              materials.push(material.userData.edgeMaterial.userData.conditionalEdgeMaterial);\n            } else {\n              materials.push(material.userData.edgeMaterial);\n            }\n          } else {\n            materials.push(null);\n          }\n        }\n      } else {\n        materials.push(elem.colorCode);\n      }\n      prevMaterial = elem.colorCode;\n      index0 = offset / 3;\n      numGroupVerts = vertices.length;\n    } else {\n      numGroupVerts += vertices.length;\n    }\n    offset += 3 * vertices.length;\n  }\n  if (numGroupVerts > 0) {\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n  }\n  bufferGeometry.setAttribute(\"position\", new BufferAttribute(positions, 3));\n  if (normals !== null) {\n    bufferGeometry.setAttribute(\"normal\", new BufferAttribute(normals, 3));\n  }\n  var object3d = null;\n  if (elementSize === 2) {\n    if (isConditionalSegments) {\n      object3d = new ConditionalLineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    } else {\n      object3d = new LineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    }\n  } else if (elementSize === 3) {\n    object3d = new Mesh(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n  }\n  if (isConditionalSegments) {\n    object3d.isConditionalLine = true;\n    var controlArray0 = new Float32Array(elements.length * 3 * 2);\n    var controlArray1 = new Float32Array(elements.length * 3 * 2);\n    var directionArray = new Float32Array(elements.length * 3 * 2);\n    for (var i = 0, _l7 = elements.length; i < _l7; i++) {\n      var os = elements[i];\n      var _vertices5 = os.vertices;\n      var controlPoints = os.controlPoints;\n      var c0 = controlPoints[0];\n      var c1 = controlPoints[1];\n      var _v5 = _vertices5[0];\n      var _v6 = _vertices5[1];\n      var _index3 = i * 3 * 2;\n      controlArray0[_index3 + 0] = c0.x;\n      controlArray0[_index3 + 1] = c0.y;\n      controlArray0[_index3 + 2] = c0.z;\n      controlArray0[_index3 + 3] = c0.x;\n      controlArray0[_index3 + 4] = c0.y;\n      controlArray0[_index3 + 5] = c0.z;\n      controlArray1[_index3 + 0] = c1.x;\n      controlArray1[_index3 + 1] = c1.y;\n      controlArray1[_index3 + 2] = c1.z;\n      controlArray1[_index3 + 3] = c1.x;\n      controlArray1[_index3 + 4] = c1.y;\n      controlArray1[_index3 + 5] = c1.z;\n      directionArray[_index3 + 0] = _v6.x - _v5.x;\n      directionArray[_index3 + 1] = _v6.y - _v5.y;\n      directionArray[_index3 + 2] = _v6.z - _v5.z;\n      directionArray[_index3 + 3] = _v6.x - _v5.x;\n      directionArray[_index3 + 4] = _v6.y - _v5.y;\n      directionArray[_index3 + 5] = _v6.z - _v5.z;\n    }\n    bufferGeometry.setAttribute(\"control0\", new BufferAttribute(controlArray0, 3, false));\n    bufferGeometry.setAttribute(\"control1\", new BufferAttribute(controlArray1, 3, false));\n    bufferGeometry.setAttribute(\"direction\", new BufferAttribute(directionArray, 3, false));\n  }\n  return object3d;\n}\nvar LDrawLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(LDrawLoader, _Loader);\n  var _super3 = _createSuper(LDrawLoader);\n  function LDrawLoader(manager) {\n    var _this5;\n    _classCallCheck(this, LDrawLoader);\n    _this5 = _super3.call(this, manager);\n    _this5.materials = [];\n    _this5.materialLibrary = {};\n    _this5.partsCache = new LDrawPartsGeometryCache(_assertThisInitialized(_this5));\n    _this5.fileMap = {};\n    _this5.setMaterials([]);\n    _this5.smoothNormals = true;\n    _this5.partsLibraryPath = \"\";\n    return _this5;\n  }\n  _createClass(LDrawLoader, [{\n    key: \"setPartsLibraryPath\",\n    value: function setPartsLibraryPath(path) {\n      this.partsLibraryPath = path;\n      return this;\n    }\n  }, {\n    key: \"preloadMaterials\",\n    value: function () {\n      var _preloadMaterials = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(url) {\n        var fileLoader, text, colorLineRegex, lines, materials, i, l, line, directive, material;\n        return _regeneratorRuntime().wrap(function _callee8$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              fileLoader = new FileLoader(this.manager);\n              fileLoader.setPath(this.path);\n              fileLoader.setRequestHeader(this.requestHeader);\n              fileLoader.setWithCredentials(this.withCredentials);\n              _context9.next = 6;\n              return fileLoader.loadAsync(url);\n            case 6:\n              text = _context9.sent;\n              colorLineRegex = /^0 !COLOUR/;\n              lines = text.split(/[\\n\\r]/g);\n              materials = [];\n              for (i = 0, l = lines.length; i < l; i++) {\n                line = lines[i];\n                if (colorLineRegex.test(line)) {\n                  directive = line.replace(colorLineRegex, \"\");\n                  material = this.parseColorMetaDirective(new LineParser(directive));\n                  materials.push(material);\n                }\n              }\n              this.setMaterials(materials);\n            case 12:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee8, this);\n      }));\n      function preloadMaterials(_x8) {\n        return _preloadMaterials.apply(this, arguments);\n      }\n      return preloadMaterials;\n    }()\n  }, {\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var _this6 = this;\n      var fileLoader = new FileLoader(this.manager);\n      fileLoader.setPath(this.path);\n      fileLoader.setRequestHeader(this.requestHeader);\n      fileLoader.setWithCredentials(this.withCredentials);\n      fileLoader.load(url, function (text) {\n        _this6.partsCache.parseModel(text, _this6.materialLibrary).then(function (group) {\n          _this6.applyMaterialsToMesh(group, MAIN_COLOUR_CODE, _this6.materialLibrary, true);\n          _this6.computeConstructionSteps(group);\n          onLoad(group);\n        }).catch(onError);\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(text, onLoad) {\n      var _this7 = this;\n      this.partsCache.parseModel(text, this.materialLibrary).then(function (group) {\n        _this7.computeConstructionSteps(group);\n        onLoad(group);\n      });\n    }\n  }, {\n    key: \"setMaterials\",\n    value: function setMaterials(materials) {\n      this.materialLibrary = {};\n      this.materials = [];\n      for (var i = 0, l = materials.length; i < l; i++) {\n        this.addMaterial(materials[i]);\n      }\n      this.addMaterial(this.parseColorMetaDirective(new LineParser(\"Main_Colour CODE 16 VALUE #FF8080 EDGE #333333\")));\n      this.addMaterial(this.parseColorMetaDirective(new LineParser(\"Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333\")));\n      return this;\n    }\n  }, {\n    key: \"setFileMap\",\n    value: function setFileMap(fileMap) {\n      this.fileMap = fileMap;\n      return this;\n    }\n  }, {\n    key: \"addMaterial\",\n    value: function addMaterial(material) {\n      var matLib = this.materialLibrary;\n      if (!matLib[material.userData.code]) {\n        this.materials.push(material);\n        matLib[material.userData.code] = material;\n      }\n      return this;\n    }\n  }, {\n    key: \"getMaterial\",\n    value: function getMaterial(colorCode) {\n      if (colorCode.startsWith(\"0x2\")) {\n        var color = colorCode.substring(3);\n        return this.parseColorMetaDirective(new LineParser(\"Direct_Color_\" + color + \" CODE -1 VALUE #\" + color + \" EDGE #\" + color));\n      }\n      return this.materialLibrary[colorCode] || null;\n    }\n    // Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n    // in the material array if they need to be filled in.\n  }, {\n    key: \"applyMaterialsToMesh\",\n    value: function applyMaterialsToMesh(group, parentColorCode, materialHierarchy) {\n      var finalMaterialPass = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var loader = this;\n      var parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;\n      group.traverse(function (c) {\n        if (c.isMesh || c.isLineSegments) {\n          if (Array.isArray(c.material)) {\n            for (var i = 0, l = c.material.length; i < l; i++) {\n              if (!c.material[i].isMaterial) {\n                c.material[i] = getMaterial(c, c.material[i]);\n              }\n            }\n          } else if (!c.material.isMaterial) {\n            c.material = getMaterial(c, c.material);\n          }\n        }\n      });\n      function getMaterial(c, colorCode) {\n        if (parentIsPassthrough && !(colorCode in materialHierarchy) && !finalMaterialPass) {\n          return colorCode;\n        }\n        var forEdge = c.isLineSegments || c.isConditionalLine;\n        var isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n        if (isPassthrough) {\n          colorCode = parentColorCode;\n        }\n        var material = null;\n        if (colorCode in materialHierarchy) {\n          material = materialHierarchy[colorCode];\n        } else if (finalMaterialPass) {\n          material = loader.getMaterial(colorCode);\n          if (material === null) {\n            throw new Error(\"LDrawLoader: Material properties for code \".concat(colorCode, \" not available.\"));\n          }\n        } else {\n          return colorCode;\n        }\n        if (c.isLineSegments) {\n          material = material.userData.edgeMaterial;\n          if (c.isConditionalLine) {\n            material = material.userData.conditionalEdgeMaterial;\n          }\n        }\n        return material;\n      }\n    }\n  }, {\n    key: \"getMainMaterial\",\n    value: function getMainMaterial() {\n      return this.getMaterial(MAIN_COLOUR_CODE);\n    }\n  }, {\n    key: \"getMainEdgeMaterial\",\n    value: function getMainEdgeMaterial() {\n      return this.getMaterial(MAIN_EDGE_COLOUR_CODE);\n    }\n  }, {\n    key: \"parseColorMetaDirective\",\n    value: function parseColorMetaDirective(lineParser) {\n      var code = null;\n      var color = 16711935;\n      var edgeColor = 16711935;\n      var alpha = 1;\n      var isTransparent = false;\n      var luminance = 0;\n      var finishType = FINISH_TYPE_DEFAULT;\n      var edgeMaterial = null;\n      var name = lineParser.getToken();\n      if (!name) {\n        throw new Error('LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + \".\");\n      }\n      var token = null;\n      while (true) {\n        token = lineParser.getToken();\n        if (!token) {\n          break;\n        }\n        switch (token.toUpperCase()) {\n          case \"CODE\":\n            code = lineParser.getToken();\n            break;\n          case \"VALUE\":\n            color = lineParser.getToken();\n            if (color.startsWith(\"0x\")) {\n              color = \"#\" + color.substring(2);\n            } else if (!color.startsWith(\"#\")) {\n              throw new Error(\"LDrawLoader: Invalid color while parsing material\" + lineParser.getLineNumberString() + \".\");\n            }\n            break;\n          case \"EDGE\":\n            edgeColor = lineParser.getToken();\n            if (edgeColor.startsWith(\"0x\")) {\n              edgeColor = \"#\" + edgeColor.substring(2);\n            } else if (!edgeColor.startsWith(\"#\")) {\n              edgeMaterial = this.getMaterial(edgeColor);\n              if (!edgeMaterial) {\n                throw new Error(\"LDrawLoader: Invalid edge color while parsing material\" + lineParser.getLineNumberString() + \".\");\n              }\n              edgeMaterial = edgeMaterial.userData.edgeMaterial;\n            }\n            break;\n          case \"ALPHA\":\n            alpha = parseInt(lineParser.getToken());\n            if (isNaN(alpha)) {\n              throw new Error(\"LDrawLoader: Invalid alpha value in material definition\" + lineParser.getLineNumberString() + \".\");\n            }\n            alpha = Math.max(0, Math.min(1, alpha / 255));\n            if (alpha < 1) {\n              isTransparent = true;\n            }\n            break;\n          case \"LUMINANCE\":\n            luminance = parseInt(lineParser.getToken());\n            if (isNaN(luminance)) {\n              throw new Error(\"LDrawLoader: Invalid luminance value in material definition\" + LineParser.getLineNumberString() + \".\");\n            }\n            luminance = Math.max(0, Math.min(1, luminance / 255));\n            break;\n          case \"CHROME\":\n            finishType = FINISH_TYPE_CHROME;\n            break;\n          case \"PEARLESCENT\":\n            finishType = FINISH_TYPE_PEARLESCENT;\n            break;\n          case \"RUBBER\":\n            finishType = FINISH_TYPE_RUBBER;\n            break;\n          case \"MATTE_METALLIC\":\n            finishType = FINISH_TYPE_MATTE_METALLIC;\n            break;\n          case \"METAL\":\n            finishType = FINISH_TYPE_METAL;\n            break;\n          case \"MATERIAL\":\n            lineParser.setToEnd();\n            break;\n          default:\n            throw new Error('LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + \".\");\n        }\n      }\n      var material = null;\n      switch (finishType) {\n        case FINISH_TYPE_DEFAULT:\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0.3,\n            metalness: 0\n          });\n          break;\n        case FINISH_TYPE_PEARLESCENT:\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0.3,\n            metalness: 0.25\n          });\n          break;\n        case FINISH_TYPE_CHROME:\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0,\n            metalness: 1\n          });\n          break;\n        case FINISH_TYPE_RUBBER:\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0.9,\n            metalness: 0\n          });\n          break;\n        case FINISH_TYPE_MATTE_METALLIC:\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0.8,\n            metalness: 0.4\n          });\n          break;\n        case FINISH_TYPE_METAL:\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0.2,\n            metalness: 0.85\n          });\n          break;\n        default:\n          break;\n      }\n      material.transparent = isTransparent;\n      material.premultipliedAlpha = true;\n      material.opacity = alpha;\n      material.depthWrite = !isTransparent;\n      material.polygonOffset = true;\n      material.polygonOffsetFactor = 1;\n      if (luminance !== 0) {\n        material.emissive.set(material.color).multiplyScalar(luminance);\n      }\n      if (!edgeMaterial) {\n        edgeMaterial = new LineBasicMaterial({\n          color: edgeColor,\n          transparent: isTransparent,\n          opacity: alpha,\n          depthWrite: !isTransparent\n        });\n        edgeMaterial.userData.code = code;\n        edgeMaterial.name = name + \" - Edge\";\n        edgeMaterial.userData.conditionalEdgeMaterial = new LDrawConditionalLineMaterial({\n          fog: true,\n          transparent: isTransparent,\n          depthWrite: !isTransparent,\n          color: edgeColor,\n          opacity: alpha\n        });\n      }\n      material.userData.code = code;\n      material.name = name;\n      material.userData.edgeMaterial = edgeMaterial;\n      this.addMaterial(material);\n      return material;\n    }\n  }, {\n    key: \"computeConstructionSteps\",\n    value: function computeConstructionSteps(model) {\n      var stepNumber = 0;\n      model.traverse(function (c) {\n        if (c.isGroup) {\n          if (c.userData.startingConstructionStep) {\n            stepNumber++;\n          }\n          c.userData.constructionStep = stepNumber;\n        }\n      });\n      model.userData.numConstructionSteps = stepNumber + 1;\n    }\n  }]);\n  return LDrawLoader;\n}(Loader);\nexport { LDrawLoader };","map":{"version":3,"names":["Vector3","ShaderMaterial","UniformsUtils","UniformsLib","Color","REVISION","LineSegments","Ray","FileLoader","Matrix4","Group","BufferGeometry","BufferAttribute","Mesh","Loader","MeshStandardMaterial","LineBasicMaterial","FINISH_TYPE_DEFAULT","FINISH_TYPE_CHROME","FINISH_TYPE_PEARLESCENT","FINISH_TYPE_RUBBER","FINISH_TYPE_MATTE_METALLIC","FINISH_TYPE_METAL","FILE_LOCATION_AS_IS","FILE_LOCATION_TRY_PARTS","FILE_LOCATION_TRY_P","FILE_LOCATION_TRY_MODELS","FILE_LOCATION_TRY_RELATIVE","FILE_LOCATION_TRY_ABSOLUTE","FILE_LOCATION_NOT_FOUND","MAIN_COLOUR_CODE","MAIN_EDGE_COLOUR_CODE","_tempVec0","_tempVec1","LDrawConditionalLineMaterial","_ShaderMaterial","_inherits","_super","_createSuper","parameters","_this","_classCallCheck","call","uniforms","merge","fog","diffuse","value","opacity","vertexShader","fragmentShader","concat","parseInt","replace","Object","defineProperties","_assertThisInitialized","get","set","color","setValues","isLDrawConditionalLineMaterial","_createClass","ConditionalLineSegments","_LineSegments","_super2","geometry","material","_this2","isConditionalLine","generateFaceNormals","faces","i","l","length","face","vertices","v0","v1","v2","subVectors","faceNormal","crossVectors","normalize","_ray","smoothNormals","lineSegments","checkSubSegments","arguments","undefined","hashMultiplier","hashVertex","v","x","y","z","hashEdge","toNormalizedRay","targetRay","direction","scalar","dot","origin","copy","addScaledVector","hashRay","ray","hardEdges","Set","hardEdgeRays","Map","halfEdgeList","normals","ls","add","rh1","has","rh2","info2","distances","info","d0","d1","_ref","push","tri","vertCount","i2","index","next","hash","rayHash","_ref2","found","i3","l2","halfEdge","key","queue","pop","vertNormals","reverseHash","otherInfo","otherTri","otherIndex","otherNormals","otherVertCount","otherFaceNormal","Math","abs","otherNext","norm","sharedNormal1","sharedNormal2","isPartType","type","isPrimitiveType","test","LineParser","line","lineNumber","lineLength","currentCharIndex","currentChar","seekNonSpace","charAt","getToken","pos0","pos1","substring","getVector","parseFloat","getRemainingString","isAtTheEnd","setToEnd","getLineNumberString","LDrawParsedCache","loader","_cache","cloneResult","original","result","map","colorCode","clone","conditionalSegments","controlPoints","category","keywords","subobjects","totalFaces","startingConstructionStep","materials","group","_fetchData","_asyncToGenerator","_regeneratorRuntime","mark","_callee","fileName","triedLowerCase","locationState","subobjectURL","fileLoader","text","wrap","_callee$","_context","prev","t0","abrupt","lastIndexOf","toLowerCase","manager","setPath","partsLibraryPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","loadAsync","sent","t1","Error","stop","fetchData","_x","apply","parse","getLocalMaterial","indexOf","lines","split","numLines","parsingEmbeddedFiles","currentEmbeddedFileName","currentEmbeddedText","bfcCertified","bfcCCW","bfcInverted","bfcCull","lineIndex","startsWith","setData","lp","lineType","segment","ccw","doubleSided","v3","c0","c1","meta","parseColorMetaDirective","userData","code","console","warn","newKeywords","forEach","keyword","trim","token","posX","posY","posZ","m0","m1","m2","m3","m4","m5","m6","m7","m8","matrix","fileName2","fileMap","inverted","getData","Promise","_ensureDataLoaded","_callee2","_this3","_callee2$","_context2","then","ensureDataLoaded","_x2","getMaterialFromCode","parentColorCode","materialHierarchy","forEdge","isPassthrough","LDrawPartsGeometryCache","parseCache","_processIntoMesh","_callee4","_this4","faceMaterials","processInfoSubobjects","_callee4$","_context5","_ref3","_callee3","subobject","promises","_loop","group2","subobjectInfos","_i4","_l3","subobject2","subobjectInfo","subobjectGroup","parentLineSegments","parentConditionalSegments","parentFaces","matrixScaleInverted","lineColorCode","_i5","_l4","os","_vertices3","_i6","_l5","_vertices4","l3","_args4","_callee3$","_context4","promise","_loop$","_context3","loadModel","catch","error","delegateYield","all","isGroup","decompose","position","quaternion","scale","name","applyMaterialsToMesh","children","determinant","applyMatrix4","reverse","_x4","size","createObject","processIntoMesh","_x3","hasCachedModel","_getCachedModel","_callee5","_callee5$","_context6","getCachedModel","_x5","_loadModel","_callee6","_callee6$","_context7","_x6","_parseModel","_callee7","_callee7$","_context8","parseModel","_x7","sortByMaterial","a","b","elements","elementSize","isConditionalSegments","totalElements","sort","positions","Float32Array","quadArray","Array","bufferGeometry","prevMaterial","index0","numGroupVerts","offset","iElem","nElem","elem","j","elemNormals","n","addGroup","edgeMaterial","conditionalEdgeMaterial","Infinity","setAttribute","object3d","controlArray0","controlArray1","directionArray","LDrawLoader","_Loader","_super3","_this5","materialLibrary","partsCache","setMaterials","setPartsLibraryPath","path","_preloadMaterials","_callee8","url","colorLineRegex","directive","_callee8$","_context9","preloadMaterials","_x8","load","onLoad","onProgress","onError","_this6","computeConstructionSteps","_this7","addMaterial","setFileMap","matLib","getMaterial","finalMaterialPass","parentIsPassthrough","traverse","c","isMesh","isLineSegments","isArray","isMaterial","getMainMaterial","getMainEdgeMaterial","lineParser","edgeColor","alpha","isTransparent","luminance","finishType","toUpperCase","isNaN","max","min","roughness","metalness","transparent","premultipliedAlpha","depthWrite","polygonOffset","polygonOffsetFactor","emissive","multiplyScalar","model","stepNumber","constructionStep","numConstructionSteps"],"sources":["/Users/rizzytwizzy/Projects/idxntity/node_modules/three-stdlib/loaders/LDrawLoader.js"],"sourcesContent":["import { Vector3, ShaderMaterial, UniformsUtils, UniformsLib, Color, REVISION, LineSegments, Ray, FileLoader, Matrix4, Group, BufferGeometry, BufferAttribute, Mesh, Loader, MeshStandardMaterial, LineBasicMaterial } from \"three\";\nconst FINISH_TYPE_DEFAULT = 0;\nconst FINISH_TYPE_CHROME = 1;\nconst FINISH_TYPE_PEARLESCENT = 2;\nconst FINISH_TYPE_RUBBER = 3;\nconst FINISH_TYPE_MATTE_METALLIC = 4;\nconst FINISH_TYPE_METAL = 5;\nconst FILE_LOCATION_AS_IS = 0;\nconst FILE_LOCATION_TRY_PARTS = 1;\nconst FILE_LOCATION_TRY_P = 2;\nconst FILE_LOCATION_TRY_MODELS = 3;\nconst FILE_LOCATION_TRY_RELATIVE = 4;\nconst FILE_LOCATION_TRY_ABSOLUTE = 5;\nconst FILE_LOCATION_NOT_FOUND = 6;\nconst MAIN_COLOUR_CODE = \"16\";\nconst MAIN_EDGE_COLOUR_CODE = \"24\";\nconst _tempVec0 = /* @__PURE__ */ new Vector3();\nconst _tempVec1 = /* @__PURE__ */ new Vector3();\nclass LDrawConditionalLineMaterial extends ShaderMaterial {\n  constructor(parameters) {\n    super({\n      uniforms: UniformsUtils.merge([\n        UniformsLib.fog,\n        {\n          diffuse: {\n            value: new Color()\n          },\n          opacity: {\n            value: 1\n          }\n        }\n      ]),\n      vertexShader: (\n        /* glsl */\n        `\n        attribute vec3 control0;\n        attribute vec3 control1;\n        attribute vec3 direction;\n        varying float discardFlag;\n\n        #include <common>\n        #include <color_pars_vertex>\n        #include <fog_pars_vertex>\n        #include <logdepthbuf_pars_vertex>\n        #include <clipping_planes_pars_vertex>\n\n        void main() {\n          #include <color_vertex>\n\n          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n          gl_Position = projectionMatrix * mvPosition;\n\n          // Transform the line segment ends and control points into camera clip space\n          vec4 c0 = projectionMatrix * modelViewMatrix * vec4(control0, 1.0);\n          vec4 c1 = projectionMatrix * modelViewMatrix * vec4(control1, 1.0);\n          vec4 p0 = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n          vec4 p1 = projectionMatrix * modelViewMatrix * vec4(position + direction, 1.0);\n\n          c0.xy /= c0.w;\n          c1.xy /= c1.w;\n          p0.xy /= p0.w;\n          p1.xy /= p1.w;\n\n          // Get the direction of the segment and an orthogonal vector\n          vec2 dir = p1.xy - p0.xy;\n          vec2 norm = vec2(-dir.y, dir.x);\n\n          // Get control point directions from the line\n          vec2 c0dir = c0.xy - p1.xy;\n          vec2 c1dir = c1.xy - p1.xy;\n\n          // If the vectors to the controls points are pointed in different directions away\n          // from the line segment then the line should not be drawn.\n          float d0 = dot(normalize(norm), normalize(c0dir));\n          float d1 = dot(normalize(norm), normalize(c1dir));\n          discardFlag = float(sign(d0) != sign(d1));\n\n          #include <logdepthbuf_vertex>\n          #include <clipping_planes_vertex>\n          #include <fog_vertex>\n        }\n      `\n      ),\n      fragmentShader: (\n        /* glsl */\n        `\n        uniform vec3 diffuse;\n        uniform float opacity;\n        varying float discardFlag;\n\n        #include <common>\n        #include <color_pars_fragment>\n        #include <fog_pars_fragment>\n        #include <logdepthbuf_pars_fragment>\n        #include <clipping_planes_pars_fragment>\n\n        void main() {\n          if (discardFlag > 0.5) discard;\n\n          #include <clipping_planes_fragment>\n          vec3 outgoingLight = vec3(0.0);\n          vec4 diffuseColor = vec4(diffuse, opacity);\n          #include <logdepthbuf_fragment>\n          #include <color_fragment>\n          outgoingLight = diffuseColor.rgb; // simple shader\n          gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n          #include <tonemapping_fragment>\n          #include <${parseInt(REVISION.replace(/\\D+/g, \"\")) >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n          #include <fog_fragment>\n          #include <premultiplied_alpha_fragment>\n        }\n      `\n      )\n    });\n    Object.defineProperties(this, {\n      opacity: {\n        get: function() {\n          return this.uniforms.opacity.value;\n        },\n        set: function(value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      color: {\n        get: function() {\n          return this.uniforms.diffuse.value;\n        }\n      }\n    });\n    this.setValues(parameters);\n    this.isLDrawConditionalLineMaterial = true;\n  }\n}\nclass ConditionalLineSegments extends LineSegments {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.isConditionalLine = true;\n  }\n}\nfunction generateFaceNormals(faces) {\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const face = faces[i];\n    const vertices = face.vertices;\n    const v0 = vertices[0];\n    const v1 = vertices[1];\n    const v2 = vertices[2];\n    _tempVec0.subVectors(v1, v0);\n    _tempVec1.subVectors(v2, v1);\n    face.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n  }\n}\nconst _ray = /* @__PURE__ */ new Ray();\nfunction smoothNormals(faces, lineSegments, checkSubSegments = false) {\n  const hashMultiplier = (1 + 1e-10) * 100;\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n  function hashEdge(v0, v1) {\n    return `${hashVertex(v0)}_${hashVertex(v1)}`;\n  }\n  function toNormalizedRay(v0, v1, targetRay) {\n    targetRay.direction.subVectors(v1, v0).normalize();\n    const scalar = v0.dot(targetRay.direction);\n    targetRay.origin.copy(v0).addScaledVector(targetRay.direction, -scalar);\n    return targetRay;\n  }\n  function hashRay(ray) {\n    return hashEdge(ray.origin, ray.direction);\n  }\n  const hardEdges = /* @__PURE__ */ new Set();\n  const hardEdgeRays = /* @__PURE__ */ new Map();\n  const halfEdgeList = {};\n  const normals = [];\n  for (let i = 0, l = lineSegments.length; i < l; i++) {\n    const ls = lineSegments[i];\n    const vertices = ls.vertices;\n    const v0 = vertices[0];\n    const v1 = vertices[1];\n    hardEdges.add(hashEdge(v0, v1));\n    hardEdges.add(hashEdge(v1, v0));\n    if (checkSubSegments) {\n      const ray = toNormalizedRay(v0, v1, new Ray());\n      const rh1 = hashRay(ray);\n      if (!hardEdgeRays.has(rh1)) {\n        toNormalizedRay(v1, v0, ray);\n        const rh2 = hashRay(ray);\n        const info2 = {\n          ray,\n          distances: []\n        };\n        hardEdgeRays.set(rh1, info2);\n        hardEdgeRays.set(rh2, info2);\n      }\n      const info = hardEdgeRays.get(rh1);\n      let d0 = info.ray.direction.dot(v0);\n      let d1 = info.ray.direction.dot(v1);\n      if (d0 > d1) {\n        ;\n        [d0, d1] = [d1, d0];\n      }\n      info.distances.push(d0, d1);\n    }\n  }\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const tri = faces[i];\n    const vertices = tri.vertices;\n    const vertCount = vertices.length;\n    for (let i2 = 0; i2 < vertCount; i2++) {\n      const index = i2;\n      const next = (i2 + 1) % vertCount;\n      const v0 = vertices[index];\n      const v1 = vertices[next];\n      const hash = hashEdge(v0, v1);\n      if (hardEdges.has(hash)) {\n        continue;\n      }\n      if (checkSubSegments) {\n        toNormalizedRay(v0, v1, _ray);\n        const rayHash = hashRay(_ray);\n        if (hardEdgeRays.has(rayHash)) {\n          const info2 = hardEdgeRays.get(rayHash);\n          const { ray, distances } = info2;\n          let d0 = ray.direction.dot(v0);\n          let d1 = ray.direction.dot(v1);\n          if (d0 > d1) {\n            ;\n            [d0, d1] = [d1, d0];\n          }\n          let found = false;\n          for (let i3 = 0, l2 = distances.length; i3 < l2; i3 += 2) {\n            if (d0 >= distances[i3] && d1 <= distances[i3 + 1]) {\n              found = true;\n              break;\n            }\n          }\n          if (found) {\n            continue;\n          }\n        }\n      }\n      const info = {\n        index,\n        tri\n      };\n      halfEdgeList[hash] = info;\n    }\n  }\n  while (true) {\n    let halfEdge = null;\n    for (const key in halfEdgeList) {\n      halfEdge = halfEdgeList[key];\n      break;\n    }\n    if (halfEdge === null) {\n      break;\n    }\n    const queue = [halfEdge];\n    while (queue.length > 0) {\n      const tri = queue.pop().tri;\n      const vertices = tri.vertices;\n      const vertNormals = tri.normals;\n      const faceNormal = tri.faceNormal;\n      const vertCount = vertices.length;\n      for (let i2 = 0; i2 < vertCount; i2++) {\n        const index = i2;\n        const next = (i2 + 1) % vertCount;\n        const v0 = vertices[index];\n        const v1 = vertices[next];\n        const hash = hashEdge(v0, v1);\n        delete halfEdgeList[hash];\n        const reverseHash = hashEdge(v1, v0);\n        const otherInfo = halfEdgeList[reverseHash];\n        if (otherInfo) {\n          const otherTri = otherInfo.tri;\n          const otherIndex = otherInfo.index;\n          const otherNormals = otherTri.normals;\n          const otherVertCount = otherNormals.length;\n          const otherFaceNormal = otherTri.faceNormal;\n          if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) {\n            continue;\n          }\n          if (reverseHash in halfEdgeList) {\n            queue.push(otherInfo);\n            delete halfEdgeList[reverseHash];\n          }\n          const otherNext = (otherIndex + 1) % otherVertCount;\n          if (vertNormals[index] && otherNormals[otherNext] && vertNormals[index] !== otherNormals[otherNext]) {\n            otherNormals[otherNext].norm.add(vertNormals[index].norm);\n            vertNormals[index].norm = otherNormals[otherNext].norm;\n          }\n          let sharedNormal1 = vertNormals[index] || otherNormals[otherNext];\n          if (sharedNormal1 === null) {\n            sharedNormal1 = { norm: new Vector3() };\n            normals.push(sharedNormal1.norm);\n          }\n          if (vertNormals[index] === null) {\n            vertNormals[index] = sharedNormal1;\n            sharedNormal1.norm.add(faceNormal);\n          }\n          if (otherNormals[otherNext] === null) {\n            otherNormals[otherNext] = sharedNormal1;\n            sharedNormal1.norm.add(otherFaceNormal);\n          }\n          if (vertNormals[next] && otherNormals[otherIndex] && vertNormals[next] !== otherNormals[otherIndex]) {\n            otherNormals[otherIndex].norm.add(vertNormals[next].norm);\n            vertNormals[next].norm = otherNormals[otherIndex].norm;\n          }\n          let sharedNormal2 = vertNormals[next] || otherNormals[otherIndex];\n          if (sharedNormal2 === null) {\n            sharedNormal2 = { norm: new Vector3() };\n            normals.push(sharedNormal2.norm);\n          }\n          if (vertNormals[next] === null) {\n            vertNormals[next] = sharedNormal2;\n            sharedNormal2.norm.add(faceNormal);\n          }\n          if (otherNormals[otherIndex] === null) {\n            otherNormals[otherIndex] = sharedNormal2;\n            sharedNormal2.norm.add(otherFaceNormal);\n          }\n        }\n      }\n    }\n  }\n  for (let i = 0, l = normals.length; i < l; i++) {\n    normals[i].normalize();\n  }\n}\nfunction isPartType(type) {\n  return type === \"Part\" || type === \"Unofficial_Part\";\n}\nfunction isPrimitiveType(type) {\n  return /primitive/i.test(type) || type === \"Subpart\";\n}\nclass LineParser {\n  constructor(line, lineNumber) {\n    this.line = line;\n    this.lineLength = line.length;\n    this.currentCharIndex = 0;\n    this.currentChar = \" \";\n    this.lineNumber = lineNumber;\n  }\n  seekNonSpace() {\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n      if (this.currentChar !== \" \" && this.currentChar !== \"\t\") {\n        return;\n      }\n      this.currentCharIndex++;\n    }\n  }\n  getToken() {\n    const pos0 = this.currentCharIndex++;\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n      if (this.currentChar === \" \" || this.currentChar === \"\t\") {\n        break;\n      }\n      this.currentCharIndex++;\n    }\n    const pos1 = this.currentCharIndex;\n    this.seekNonSpace();\n    return this.line.substring(pos0, pos1);\n  }\n  getVector() {\n    return new Vector3(parseFloat(this.getToken()), parseFloat(this.getToken()), parseFloat(this.getToken()));\n  }\n  getRemainingString() {\n    return this.line.substring(this.currentCharIndex, this.lineLength);\n  }\n  isAtTheEnd() {\n    return this.currentCharIndex >= this.lineLength;\n  }\n  setToEnd() {\n    this.currentCharIndex = this.lineLength;\n  }\n  getLineNumberString() {\n    return this.lineNumber >= 0 ? \" at line \" + this.lineNumber : \"\";\n  }\n}\nclass LDrawParsedCache {\n  constructor(loader) {\n    this.loader = loader;\n    this._cache = {};\n  }\n  cloneResult(original) {\n    const result = {};\n    result.faces = original.faces.map((face) => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map((v) => v.clone()),\n        normals: face.normals.map(() => null),\n        faceNormal: null\n      };\n    });\n    result.conditionalSegments = original.conditionalSegments.map((face) => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map((v) => v.clone()),\n        controlPoints: face.controlPoints.map((v) => v.clone())\n      };\n    });\n    result.lineSegments = original.lineSegments.map((face) => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map((v) => v.clone())\n      };\n    });\n    result.type = original.type;\n    result.category = original.category;\n    result.keywords = original.keywords;\n    result.subobjects = original.subobjects;\n    result.totalFaces = original.totalFaces;\n    result.startingConstructionStep = original.startingConstructionStep;\n    result.materials = original.materials;\n    result.group = null;\n    return result;\n  }\n  async fetchData(fileName) {\n    let triedLowerCase = false;\n    let locationState = FILE_LOCATION_AS_IS;\n    while (locationState !== FILE_LOCATION_NOT_FOUND) {\n      let subobjectURL = fileName;\n      switch (locationState) {\n        case FILE_LOCATION_AS_IS:\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_PARTS:\n          subobjectURL = \"parts/\" + subobjectURL;\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_P:\n          subobjectURL = \"p/\" + subobjectURL;\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_MODELS:\n          subobjectURL = \"models/\" + subobjectURL;\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_RELATIVE:\n          subobjectURL = fileName.substring(0, fileName.lastIndexOf(\"/\") + 1) + subobjectURL;\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_ABSOLUTE:\n          if (triedLowerCase) {\n            locationState = FILE_LOCATION_NOT_FOUND;\n          } else {\n            fileName = fileName.toLowerCase();\n            subobjectURL = fileName;\n            triedLowerCase = true;\n            locationState = FILE_LOCATION_AS_IS;\n          }\n          break;\n      }\n      const loader = this.loader;\n      const fileLoader = new FileLoader(loader.manager);\n      fileLoader.setPath(loader.partsLibraryPath);\n      fileLoader.setRequestHeader(loader.requestHeader);\n      fileLoader.setWithCredentials(loader.withCredentials);\n      try {\n        const text = await fileLoader.loadAsync(subobjectURL);\n        return text;\n      } catch (e) {\n        continue;\n      }\n    }\n    throw new Error('LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.');\n  }\n  parse(text, fileName = null) {\n    const loader = this.loader;\n    const faces = [];\n    const lineSegments = [];\n    const conditionalSegments = [];\n    const subobjects = [];\n    const materials = {};\n    const getLocalMaterial = (colorCode) => {\n      return materials[colorCode] || null;\n    };\n    let type = \"Model\";\n    let category = null;\n    let keywords = null;\n    let totalFaces = 0;\n    if (text.indexOf(\"\\r\\n\") !== -1) {\n      text = text.replace(/\\r\\n/g, \"\\n\");\n    }\n    const lines = text.split(\"\\n\");\n    const numLines = lines.length;\n    let parsingEmbeddedFiles = false;\n    let currentEmbeddedFileName = null;\n    let currentEmbeddedText = null;\n    let bfcCertified = false;\n    let bfcCCW = true;\n    let bfcInverted = false;\n    let bfcCull = true;\n    let startingConstructionStep = false;\n    for (let lineIndex = 0; lineIndex < numLines; lineIndex++) {\n      const line = lines[lineIndex];\n      if (line.length === 0)\n        continue;\n      if (parsingEmbeddedFiles) {\n        if (line.startsWith(\"0 FILE \")) {\n          this.setData(currentEmbeddedFileName, currentEmbeddedText);\n          currentEmbeddedFileName = line.substring(7);\n          currentEmbeddedText = \"\";\n        } else {\n          currentEmbeddedText += line + \"\\n\";\n        }\n        continue;\n      }\n      const lp = new LineParser(line, lineIndex + 1);\n      lp.seekNonSpace();\n      if (lp.isAtTheEnd()) {\n        continue;\n      }\n      const lineType = lp.getToken();\n      let material;\n      let colorCode;\n      let segment;\n      let ccw;\n      let doubleSided;\n      let v0, v1, v2, v3, c0, c1;\n      switch (lineType) {\n        case \"0\":\n          const meta = lp.getToken();\n          if (meta) {\n            switch (meta) {\n              case \"!LDRAW_ORG\":\n                type = lp.getToken();\n                break;\n              case \"!COLOUR\":\n                material = loader.parseColorMetaDirective(lp);\n                if (material) {\n                  materials[material.userData.code] = material;\n                } else {\n                  console.warn(\"LDrawLoader: Error parsing material\" + lp.getLineNumberString());\n                }\n                break;\n              case \"!CATEGORY\":\n                category = lp.getToken();\n                break;\n              case \"!KEYWORDS\":\n                const newKeywords = lp.getRemainingString().split(\",\");\n                if (newKeywords.length > 0) {\n                  if (!keywords) {\n                    keywords = [];\n                  }\n                  newKeywords.forEach(function(keyword) {\n                    keywords.push(keyword.trim());\n                  });\n                }\n                break;\n              case \"FILE\":\n                if (lineIndex > 0) {\n                  parsingEmbeddedFiles = true;\n                  currentEmbeddedFileName = lp.getRemainingString();\n                  currentEmbeddedText = \"\";\n                  bfcCertified = false;\n                  bfcCCW = true;\n                }\n                break;\n              case \"BFC\":\n                while (!lp.isAtTheEnd()) {\n                  const token = lp.getToken();\n                  switch (token) {\n                    case \"CERTIFY\":\n                    case \"NOCERTIFY\":\n                      bfcCertified = token === \"CERTIFY\";\n                      bfcCCW = true;\n                      break;\n                    case \"CW\":\n                    case \"CCW\":\n                      bfcCCW = token === \"CCW\";\n                      break;\n                    case \"INVERTNEXT\":\n                      bfcInverted = true;\n                      break;\n                    case \"CLIP\":\n                    case \"NOCLIP\":\n                      bfcCull = token === \"CLIP\";\n                      break;\n                    default:\n                      console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                      break;\n                  }\n                }\n                break;\n              case \"STEP\":\n                startingConstructionStep = true;\n                break;\n              default:\n                break;\n            }\n          }\n          break;\n        case \"1\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          const posX = parseFloat(lp.getToken());\n          const posY = parseFloat(lp.getToken());\n          const posZ = parseFloat(lp.getToken());\n          const m0 = parseFloat(lp.getToken());\n          const m1 = parseFloat(lp.getToken());\n          const m2 = parseFloat(lp.getToken());\n          const m3 = parseFloat(lp.getToken());\n          const m4 = parseFloat(lp.getToken());\n          const m5 = parseFloat(lp.getToken());\n          const m6 = parseFloat(lp.getToken());\n          const m7 = parseFloat(lp.getToken());\n          const m8 = parseFloat(lp.getToken());\n          const matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n          let fileName2 = lp.getRemainingString().trim().replace(/\\\\/g, \"/\");\n          if (loader.fileMap[fileName2]) {\n            fileName2 = loader.fileMap[fileName2];\n          } else {\n            if (fileName2.startsWith(\"s/\")) {\n              fileName2 = \"parts/\" + fileName2;\n            } else if (fileName2.startsWith(\"48/\")) {\n              fileName2 = \"p/\" + fileName2;\n            }\n          }\n          subobjects.push({\n            material,\n            colorCode,\n            matrix,\n            fileName: fileName2,\n            inverted: bfcInverted,\n            startingConstructionStep\n          });\n          bfcInverted = false;\n          break;\n        case \"2\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          v0 = lp.getVector();\n          v1 = lp.getVector();\n          segment = {\n            material,\n            colorCode,\n            vertices: [v0, v1]\n          };\n          lineSegments.push(segment);\n          break;\n        case \"5\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          v0 = lp.getVector();\n          v1 = lp.getVector();\n          c0 = lp.getVector();\n          c1 = lp.getVector();\n          segment = {\n            material,\n            colorCode,\n            vertices: [v0, v1],\n            controlPoints: [c0, c1]\n          };\n          conditionalSegments.push(segment);\n          break;\n        case \"3\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          ccw = bfcCCW;\n          doubleSided = !bfcCertified || !bfcCull;\n          if (ccw === true) {\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            v2 = lp.getVector();\n          } else {\n            v2 = lp.getVector();\n            v1 = lp.getVector();\n            v0 = lp.getVector();\n          }\n          faces.push({\n            material,\n            colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2],\n            normals: [null, null, null]\n          });\n          totalFaces++;\n          if (doubleSided === true) {\n            faces.push({\n              material,\n              colorCode,\n              faceNormal: null,\n              vertices: [v2, v1, v0],\n              normals: [null, null, null]\n            });\n            totalFaces++;\n          }\n          break;\n        case \"4\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          ccw = bfcCCW;\n          doubleSided = !bfcCertified || !bfcCull;\n          if (ccw === true) {\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            v2 = lp.getVector();\n            v3 = lp.getVector();\n          } else {\n            v3 = lp.getVector();\n            v2 = lp.getVector();\n            v1 = lp.getVector();\n            v0 = lp.getVector();\n          }\n          faces.push({\n            material,\n            colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2, v3],\n            normals: [null, null, null, null]\n          });\n          totalFaces += 2;\n          if (doubleSided === true) {\n            faces.push({\n              material,\n              colorCode,\n              faceNormal: null,\n              vertices: [v3, v2, v1, v0],\n              normals: [null, null, null, null]\n            });\n            totalFaces += 2;\n          }\n          break;\n        default:\n          throw new Error('LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + \".\");\n      }\n    }\n    if (parsingEmbeddedFiles) {\n      this.setData(currentEmbeddedFileName, currentEmbeddedText);\n    }\n    return {\n      faces,\n      conditionalSegments,\n      lineSegments,\n      type,\n      category,\n      keywords,\n      subobjects,\n      totalFaces,\n      startingConstructionStep,\n      materials,\n      fileName,\n      group: null\n    };\n  }\n  // returns an (optionally cloned) instance of the data\n  getData(fileName, clone = true) {\n    const key = fileName.toLowerCase();\n    const result = this._cache[key];\n    if (result === null || result instanceof Promise) {\n      return null;\n    }\n    if (clone) {\n      return this.cloneResult(result);\n    } else {\n      return result;\n    }\n  }\n  // kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n  // the data is ready to use and can be retrieved synchronously with \"getData\".\n  async ensureDataLoaded(fileName) {\n    const key = fileName.toLowerCase();\n    if (!(key in this._cache)) {\n      this._cache[key] = this.fetchData(fileName).then((text) => {\n        const info = this.parse(text, fileName);\n        this._cache[key] = info;\n        return info;\n      });\n    }\n    await this._cache[key];\n  }\n  // sets the data in the cache from parsed data\n  setData(fileName, text) {\n    const key = fileName.toLowerCase();\n    this._cache[key] = this.parse(text, fileName);\n  }\n}\nfunction getMaterialFromCode(colorCode, parentColorCode, materialHierarchy, forEdge) {\n  const isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n  if (isPassthrough) {\n    colorCode = parentColorCode;\n  }\n  return materialHierarchy[colorCode] || null;\n}\nclass LDrawPartsGeometryCache {\n  constructor(loader) {\n    this.loader = loader;\n    this.parseCache = new LDrawParsedCache(loader);\n    this._cache = {};\n  }\n  // Convert the given file information into a mesh by processing subobjects.\n  async processIntoMesh(info) {\n    const loader = this.loader;\n    const parseCache = this.parseCache;\n    const faceMaterials = /* @__PURE__ */ new Set();\n    const processInfoSubobjects = async (info2, subobject = null) => {\n      const subobjects = info2.subobjects;\n      const promises = [];\n      for (let i = 0, l = subobjects.length; i < l; i++) {\n        const subobject2 = subobjects[i];\n        const promise = parseCache.ensureDataLoaded(subobject2.fileName).then(() => {\n          const subobjectInfo = parseCache.getData(subobject2.fileName, false);\n          if (!isPrimitiveType(subobjectInfo.type)) {\n            return this.loadModel(subobject2.fileName).catch((error) => {\n              console.warn(error);\n              return null;\n            });\n          }\n          return processInfoSubobjects(parseCache.getData(subobject2.fileName), subobject2);\n        });\n        promises.push(promise);\n      }\n      const group2 = new Group();\n      group2.userData.category = info2.category;\n      group2.userData.keywords = info2.keywords;\n      info2.group = group2;\n      const subobjectInfos = await Promise.all(promises);\n      for (let i = 0, l = subobjectInfos.length; i < l; i++) {\n        const subobject2 = info2.subobjects[i];\n        const subobjectInfo = subobjectInfos[i];\n        if (subobjectInfo === null) {\n          continue;\n        }\n        if (subobjectInfo.isGroup) {\n          const subobjectGroup = subobjectInfo;\n          subobject2.matrix.decompose(subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale);\n          subobjectGroup.userData.startingConstructionStep = subobject2.startingConstructionStep;\n          subobjectGroup.name = subobject2.fileName;\n          loader.applyMaterialsToMesh(subobjectGroup, subobject2.colorCode, info2.materials);\n          group2.add(subobjectGroup);\n          continue;\n        }\n        if (subobjectInfo.group.children.length) {\n          group2.add(subobjectInfo.group);\n        }\n        const parentLineSegments = info2.lineSegments;\n        const parentConditionalSegments = info2.conditionalSegments;\n        const parentFaces = info2.faces;\n        const lineSegments = subobjectInfo.lineSegments;\n        const conditionalSegments = subobjectInfo.conditionalSegments;\n        const faces = subobjectInfo.faces;\n        const matrix = subobject2.matrix;\n        const inverted = subobject2.inverted;\n        const matrixScaleInverted = matrix.determinant() < 0;\n        const colorCode = subobject2.colorCode;\n        const lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;\n        for (let i2 = 0, l2 = lineSegments.length; i2 < l2; i2++) {\n          const ls = lineSegments[i2];\n          const vertices = ls.vertices;\n          vertices[0].applyMatrix4(matrix);\n          vertices[1].applyMatrix4(matrix);\n          ls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;\n          ls.material = ls.material || getMaterialFromCode(ls.colorCode, ls.colorCode, info2.materials, true);\n          parentLineSegments.push(ls);\n        }\n        for (let i2 = 0, l2 = conditionalSegments.length; i2 < l2; i2++) {\n          const os = conditionalSegments[i2];\n          const vertices = os.vertices;\n          const controlPoints = os.controlPoints;\n          vertices[0].applyMatrix4(matrix);\n          vertices[1].applyMatrix4(matrix);\n          controlPoints[0].applyMatrix4(matrix);\n          controlPoints[1].applyMatrix4(matrix);\n          os.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;\n          os.material = os.material || getMaterialFromCode(os.colorCode, os.colorCode, info2.materials, true);\n          parentConditionalSegments.push(os);\n        }\n        for (let i2 = 0, l2 = faces.length; i2 < l2; i2++) {\n          const tri = faces[i2];\n          const vertices = tri.vertices;\n          for (let i3 = 0, l3 = vertices.length; i3 < l3; i3++) {\n            vertices[i3].applyMatrix4(matrix);\n          }\n          tri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;\n          tri.material = tri.material || getMaterialFromCode(tri.colorCode, colorCode, info2.materials, false);\n          faceMaterials.add(tri.colorCode);\n          if (matrixScaleInverted !== inverted) {\n            vertices.reverse();\n          }\n          parentFaces.push(tri);\n        }\n        info2.totalFaces += subobjectInfo.totalFaces;\n      }\n      if (subobject) {\n        loader.applyMaterialsToMesh(group2, subobject.colorCode, info2.materials);\n      }\n      return info2;\n    };\n    for (let i = 0, l = info.faces; i < l; i++) {\n      faceMaterials.add(info.faces[i].colorCode);\n    }\n    await processInfoSubobjects(info);\n    if (loader.smoothNormals) {\n      const checkSubSegments = faceMaterials.size > 1;\n      generateFaceNormals(info.faces);\n      smoothNormals(info.faces, info.lineSegments, checkSubSegments);\n    }\n    const group = info.group;\n    if (info.faces.length > 0) {\n      group.add(createObject(info.faces, 3, false, info.totalFaces));\n    }\n    if (info.lineSegments.length > 0) {\n      group.add(createObject(info.lineSegments, 2));\n    }\n    if (info.conditionalSegments.length > 0) {\n      group.add(createObject(info.conditionalSegments, 2, true));\n    }\n    return group;\n  }\n  hasCachedModel(fileName) {\n    return fileName !== null && fileName.toLowerCase() in this._cache;\n  }\n  async getCachedModel(fileName) {\n    if (fileName !== null && this.hasCachedModel(fileName)) {\n      const key = fileName.toLowerCase();\n      const group = await this._cache[key];\n      return group.clone();\n    } else {\n      return null;\n    }\n  }\n  // Loads and parses the model with the given file name. Returns a cached copy if available.\n  async loadModel(fileName) {\n    const parseCache = this.parseCache;\n    const key = fileName.toLowerCase();\n    if (this.hasCachedModel(fileName)) {\n      return this.getCachedModel(fileName);\n    } else {\n      await parseCache.ensureDataLoaded(fileName);\n      const info = parseCache.getData(fileName);\n      const promise = this.processIntoMesh(info);\n      if (this.hasCachedModel(fileName)) {\n        return this.getCachedModel(fileName);\n      }\n      if (isPartType(info.type)) {\n        this._cache[key] = promise;\n      }\n      const group = await promise;\n      return group.clone();\n    }\n  }\n  // parses the given model text into a renderable object. Returns cached copy if available.\n  async parseModel(text) {\n    const parseCache = this.parseCache;\n    const info = parseCache.parse(text);\n    if (isPartType(info.type) && this.hasCachedModel(info.fileName)) {\n      return this.getCachedModel(info.fileName);\n    }\n    return this.processIntoMesh(info);\n  }\n}\nfunction sortByMaterial(a, b) {\n  if (a.colorCode === b.colorCode) {\n    return 0;\n  }\n  if (a.colorCode < b.colorCode) {\n    return -1;\n  }\n  return 1;\n}\nfunction createObject(elements, elementSize, isConditionalSegments = false, totalElements = null) {\n  elements.sort(sortByMaterial);\n  if (totalElements === null) {\n    totalElements = elements.length;\n  }\n  const positions = new Float32Array(elementSize * totalElements * 3);\n  const normals = elementSize === 3 ? new Float32Array(elementSize * totalElements * 3) : null;\n  const materials = [];\n  const quadArray = new Array(6);\n  const bufferGeometry = new BufferGeometry();\n  let prevMaterial = null;\n  let index0 = 0;\n  let numGroupVerts = 0;\n  let offset = 0;\n  for (let iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n    const elem = elements[iElem];\n    let vertices = elem.vertices;\n    if (vertices.length === 4) {\n      quadArray[0] = vertices[0];\n      quadArray[1] = vertices[1];\n      quadArray[2] = vertices[2];\n      quadArray[3] = vertices[0];\n      quadArray[4] = vertices[2];\n      quadArray[5] = vertices[3];\n      vertices = quadArray;\n    }\n    for (let j = 0, l = vertices.length; j < l; j++) {\n      const v = vertices[j];\n      const index = offset + j * 3;\n      positions[index + 0] = v.x;\n      positions[index + 1] = v.y;\n      positions[index + 2] = v.z;\n    }\n    if (elementSize === 3) {\n      if (!elem.faceNormal) {\n        const v0 = vertices[0];\n        const v1 = vertices[1];\n        const v2 = vertices[2];\n        _tempVec0.subVectors(v1, v0);\n        _tempVec1.subVectors(v2, v1);\n        elem.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n      }\n      let elemNormals = elem.normals;\n      if (elemNormals.length === 4) {\n        quadArray[0] = elemNormals[0];\n        quadArray[1] = elemNormals[1];\n        quadArray[2] = elemNormals[2];\n        quadArray[3] = elemNormals[0];\n        quadArray[4] = elemNormals[2];\n        quadArray[5] = elemNormals[3];\n        elemNormals = quadArray;\n      }\n      for (let j = 0, l = elemNormals.length; j < l; j++) {\n        let n = elem.faceNormal;\n        if (elemNormals[j]) {\n          n = elemNormals[j].norm;\n        }\n        const index = offset + j * 3;\n        normals[index + 0] = n.x;\n        normals[index + 1] = n.y;\n        normals[index + 2] = n.z;\n      }\n    }\n    if (prevMaterial !== elem.colorCode) {\n      if (prevMaterial !== null) {\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n      }\n      const material = elem.material;\n      if (material !== null) {\n        if (elementSize === 3) {\n          materials.push(material);\n        } else if (elementSize === 2) {\n          if (material !== null) {\n            if (isConditionalSegments) {\n              materials.push(material.userData.edgeMaterial.userData.conditionalEdgeMaterial);\n            } else {\n              materials.push(material.userData.edgeMaterial);\n            }\n          } else {\n            materials.push(null);\n          }\n        }\n      } else {\n        materials.push(elem.colorCode);\n      }\n      prevMaterial = elem.colorCode;\n      index0 = offset / 3;\n      numGroupVerts = vertices.length;\n    } else {\n      numGroupVerts += vertices.length;\n    }\n    offset += 3 * vertices.length;\n  }\n  if (numGroupVerts > 0) {\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n  }\n  bufferGeometry.setAttribute(\"position\", new BufferAttribute(positions, 3));\n  if (normals !== null) {\n    bufferGeometry.setAttribute(\"normal\", new BufferAttribute(normals, 3));\n  }\n  let object3d = null;\n  if (elementSize === 2) {\n    if (isConditionalSegments) {\n      object3d = new ConditionalLineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    } else {\n      object3d = new LineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    }\n  } else if (elementSize === 3) {\n    object3d = new Mesh(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n  }\n  if (isConditionalSegments) {\n    object3d.isConditionalLine = true;\n    const controlArray0 = new Float32Array(elements.length * 3 * 2);\n    const controlArray1 = new Float32Array(elements.length * 3 * 2);\n    const directionArray = new Float32Array(elements.length * 3 * 2);\n    for (let i = 0, l = elements.length; i < l; i++) {\n      const os = elements[i];\n      const vertices = os.vertices;\n      const controlPoints = os.controlPoints;\n      const c0 = controlPoints[0];\n      const c1 = controlPoints[1];\n      const v0 = vertices[0];\n      const v1 = vertices[1];\n      const index = i * 3 * 2;\n      controlArray0[index + 0] = c0.x;\n      controlArray0[index + 1] = c0.y;\n      controlArray0[index + 2] = c0.z;\n      controlArray0[index + 3] = c0.x;\n      controlArray0[index + 4] = c0.y;\n      controlArray0[index + 5] = c0.z;\n      controlArray1[index + 0] = c1.x;\n      controlArray1[index + 1] = c1.y;\n      controlArray1[index + 2] = c1.z;\n      controlArray1[index + 3] = c1.x;\n      controlArray1[index + 4] = c1.y;\n      controlArray1[index + 5] = c1.z;\n      directionArray[index + 0] = v1.x - v0.x;\n      directionArray[index + 1] = v1.y - v0.y;\n      directionArray[index + 2] = v1.z - v0.z;\n      directionArray[index + 3] = v1.x - v0.x;\n      directionArray[index + 4] = v1.y - v0.y;\n      directionArray[index + 5] = v1.z - v0.z;\n    }\n    bufferGeometry.setAttribute(\"control0\", new BufferAttribute(controlArray0, 3, false));\n    bufferGeometry.setAttribute(\"control1\", new BufferAttribute(controlArray1, 3, false));\n    bufferGeometry.setAttribute(\"direction\", new BufferAttribute(directionArray, 3, false));\n  }\n  return object3d;\n}\nclass LDrawLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.materials = [];\n    this.materialLibrary = {};\n    this.partsCache = new LDrawPartsGeometryCache(this);\n    this.fileMap = {};\n    this.setMaterials([]);\n    this.smoothNormals = true;\n    this.partsLibraryPath = \"\";\n  }\n  setPartsLibraryPath(path) {\n    this.partsLibraryPath = path;\n    return this;\n  }\n  async preloadMaterials(url) {\n    const fileLoader = new FileLoader(this.manager);\n    fileLoader.setPath(this.path);\n    fileLoader.setRequestHeader(this.requestHeader);\n    fileLoader.setWithCredentials(this.withCredentials);\n    const text = await fileLoader.loadAsync(url);\n    const colorLineRegex = /^0 !COLOUR/;\n    const lines = text.split(/[\\n\\r]/g);\n    const materials = [];\n    for (let i = 0, l = lines.length; i < l; i++) {\n      const line = lines[i];\n      if (colorLineRegex.test(line)) {\n        const directive = line.replace(colorLineRegex, \"\");\n        const material = this.parseColorMetaDirective(new LineParser(directive));\n        materials.push(material);\n      }\n    }\n    this.setMaterials(materials);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const fileLoader = new FileLoader(this.manager);\n    fileLoader.setPath(this.path);\n    fileLoader.setRequestHeader(this.requestHeader);\n    fileLoader.setWithCredentials(this.withCredentials);\n    fileLoader.load(\n      url,\n      (text) => {\n        this.partsCache.parseModel(text, this.materialLibrary).then((group) => {\n          this.applyMaterialsToMesh(group, MAIN_COLOUR_CODE, this.materialLibrary, true);\n          this.computeConstructionSteps(group);\n          onLoad(group);\n        }).catch(onError);\n      },\n      onProgress,\n      onError\n    );\n  }\n  parse(text, onLoad) {\n    this.partsCache.parseModel(text, this.materialLibrary).then((group) => {\n      this.computeConstructionSteps(group);\n      onLoad(group);\n    });\n  }\n  setMaterials(materials) {\n    this.materialLibrary = {};\n    this.materials = [];\n    for (let i = 0, l = materials.length; i < l; i++) {\n      this.addMaterial(materials[i]);\n    }\n    this.addMaterial(this.parseColorMetaDirective(new LineParser(\"Main_Colour CODE 16 VALUE #FF8080 EDGE #333333\")));\n    this.addMaterial(this.parseColorMetaDirective(new LineParser(\"Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333\")));\n    return this;\n  }\n  setFileMap(fileMap) {\n    this.fileMap = fileMap;\n    return this;\n  }\n  addMaterial(material) {\n    const matLib = this.materialLibrary;\n    if (!matLib[material.userData.code]) {\n      this.materials.push(material);\n      matLib[material.userData.code] = material;\n    }\n    return this;\n  }\n  getMaterial(colorCode) {\n    if (colorCode.startsWith(\"0x2\")) {\n      const color = colorCode.substring(3);\n      return this.parseColorMetaDirective(\n        new LineParser(\"Direct_Color_\" + color + \" CODE -1 VALUE #\" + color + \" EDGE #\" + color)\n      );\n    }\n    return this.materialLibrary[colorCode] || null;\n  }\n  // Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n  // in the material array if they need to be filled in.\n  applyMaterialsToMesh(group, parentColorCode, materialHierarchy, finalMaterialPass = false) {\n    const loader = this;\n    const parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;\n    group.traverse((c) => {\n      if (c.isMesh || c.isLineSegments) {\n        if (Array.isArray(c.material)) {\n          for (let i = 0, l = c.material.length; i < l; i++) {\n            if (!c.material[i].isMaterial) {\n              c.material[i] = getMaterial(c, c.material[i]);\n            }\n          }\n        } else if (!c.material.isMaterial) {\n          c.material = getMaterial(c, c.material);\n        }\n      }\n    });\n    function getMaterial(c, colorCode) {\n      if (parentIsPassthrough && !(colorCode in materialHierarchy) && !finalMaterialPass) {\n        return colorCode;\n      }\n      const forEdge = c.isLineSegments || c.isConditionalLine;\n      const isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n      if (isPassthrough) {\n        colorCode = parentColorCode;\n      }\n      let material = null;\n      if (colorCode in materialHierarchy) {\n        material = materialHierarchy[colorCode];\n      } else if (finalMaterialPass) {\n        material = loader.getMaterial(colorCode);\n        if (material === null) {\n          throw new Error(`LDrawLoader: Material properties for code ${colorCode} not available.`);\n        }\n      } else {\n        return colorCode;\n      }\n      if (c.isLineSegments) {\n        material = material.userData.edgeMaterial;\n        if (c.isConditionalLine) {\n          material = material.userData.conditionalEdgeMaterial;\n        }\n      }\n      return material;\n    }\n  }\n  getMainMaterial() {\n    return this.getMaterial(MAIN_COLOUR_CODE);\n  }\n  getMainEdgeMaterial() {\n    return this.getMaterial(MAIN_EDGE_COLOUR_CODE);\n  }\n  parseColorMetaDirective(lineParser) {\n    let code = null;\n    let color = 16711935;\n    let edgeColor = 16711935;\n    let alpha = 1;\n    let isTransparent = false;\n    let luminance = 0;\n    let finishType = FINISH_TYPE_DEFAULT;\n    let edgeMaterial = null;\n    const name = lineParser.getToken();\n    if (!name) {\n      throw new Error(\n        'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + \".\"\n      );\n    }\n    let token = null;\n    while (true) {\n      token = lineParser.getToken();\n      if (!token) {\n        break;\n      }\n      switch (token.toUpperCase()) {\n        case \"CODE\":\n          code = lineParser.getToken();\n          break;\n        case \"VALUE\":\n          color = lineParser.getToken();\n          if (color.startsWith(\"0x\")) {\n            color = \"#\" + color.substring(2);\n          } else if (!color.startsWith(\"#\")) {\n            throw new Error(\n              \"LDrawLoader: Invalid color while parsing material\" + lineParser.getLineNumberString() + \".\"\n            );\n          }\n          break;\n        case \"EDGE\":\n          edgeColor = lineParser.getToken();\n          if (edgeColor.startsWith(\"0x\")) {\n            edgeColor = \"#\" + edgeColor.substring(2);\n          } else if (!edgeColor.startsWith(\"#\")) {\n            edgeMaterial = this.getMaterial(edgeColor);\n            if (!edgeMaterial) {\n              throw new Error(\n                \"LDrawLoader: Invalid edge color while parsing material\" + lineParser.getLineNumberString() + \".\"\n              );\n            }\n            edgeMaterial = edgeMaterial.userData.edgeMaterial;\n          }\n          break;\n        case \"ALPHA\":\n          alpha = parseInt(lineParser.getToken());\n          if (isNaN(alpha)) {\n            throw new Error(\n              \"LDrawLoader: Invalid alpha value in material definition\" + lineParser.getLineNumberString() + \".\"\n            );\n          }\n          alpha = Math.max(0, Math.min(1, alpha / 255));\n          if (alpha < 1) {\n            isTransparent = true;\n          }\n          break;\n        case \"LUMINANCE\":\n          luminance = parseInt(lineParser.getToken());\n          if (isNaN(luminance)) {\n            throw new Error(\n              \"LDrawLoader: Invalid luminance value in material definition\" + LineParser.getLineNumberString() + \".\"\n            );\n          }\n          luminance = Math.max(0, Math.min(1, luminance / 255));\n          break;\n        case \"CHROME\":\n          finishType = FINISH_TYPE_CHROME;\n          break;\n        case \"PEARLESCENT\":\n          finishType = FINISH_TYPE_PEARLESCENT;\n          break;\n        case \"RUBBER\":\n          finishType = FINISH_TYPE_RUBBER;\n          break;\n        case \"MATTE_METALLIC\":\n          finishType = FINISH_TYPE_MATTE_METALLIC;\n          break;\n        case \"METAL\":\n          finishType = FINISH_TYPE_METAL;\n          break;\n        case \"MATERIAL\":\n          lineParser.setToEnd();\n          break;\n        default:\n          throw new Error(\n            'LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + \".\"\n          );\n      }\n    }\n    let material = null;\n    switch (finishType) {\n      case FINISH_TYPE_DEFAULT:\n        material = new MeshStandardMaterial({ color, roughness: 0.3, metalness: 0 });\n        break;\n      case FINISH_TYPE_PEARLESCENT:\n        material = new MeshStandardMaterial({ color, roughness: 0.3, metalness: 0.25 });\n        break;\n      case FINISH_TYPE_CHROME:\n        material = new MeshStandardMaterial({ color, roughness: 0, metalness: 1 });\n        break;\n      case FINISH_TYPE_RUBBER:\n        material = new MeshStandardMaterial({ color, roughness: 0.9, metalness: 0 });\n        break;\n      case FINISH_TYPE_MATTE_METALLIC:\n        material = new MeshStandardMaterial({ color, roughness: 0.8, metalness: 0.4 });\n        break;\n      case FINISH_TYPE_METAL:\n        material = new MeshStandardMaterial({ color, roughness: 0.2, metalness: 0.85 });\n        break;\n      default:\n        break;\n    }\n    material.transparent = isTransparent;\n    material.premultipliedAlpha = true;\n    material.opacity = alpha;\n    material.depthWrite = !isTransparent;\n    material.polygonOffset = true;\n    material.polygonOffsetFactor = 1;\n    if (luminance !== 0) {\n      material.emissive.set(material.color).multiplyScalar(luminance);\n    }\n    if (!edgeMaterial) {\n      edgeMaterial = new LineBasicMaterial({\n        color: edgeColor,\n        transparent: isTransparent,\n        opacity: alpha,\n        depthWrite: !isTransparent\n      });\n      edgeMaterial.userData.code = code;\n      edgeMaterial.name = name + \" - Edge\";\n      edgeMaterial.userData.conditionalEdgeMaterial = new LDrawConditionalLineMaterial({\n        fog: true,\n        transparent: isTransparent,\n        depthWrite: !isTransparent,\n        color: edgeColor,\n        opacity: alpha\n      });\n    }\n    material.userData.code = code;\n    material.name = name;\n    material.userData.edgeMaterial = edgeMaterial;\n    this.addMaterial(material);\n    return material;\n  }\n  computeConstructionSteps(model) {\n    let stepNumber = 0;\n    model.traverse((c) => {\n      if (c.isGroup) {\n        if (c.userData.startingConstructionStep) {\n          stepNumber++;\n        }\n        c.userData.constructionStep = stepNumber;\n      }\n    });\n    model.userData.numConstructionSteps = stepNumber + 1;\n  }\n}\nexport {\n  LDrawLoader\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}