{"ast":null,"code":"import _classCallCheck from \"/Users/rizzytwizzy/Projects/idxntity/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rizzytwizzy/Projects/idxntity/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/rizzytwizzy/Projects/idxntity/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/rizzytwizzy/Projects/idxntity/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport * as THREE from 'three';\nvar _instanceLocalMatrix = /*@__PURE__*/new THREE.Matrix4();\nvar _instanceWorldMatrix = /*@__PURE__*/new THREE.Matrix4();\nvar _instanceIntersects = [];\nvar _mesh = /*@__PURE__*/new THREE.Mesh();\nvar Position = /*#__PURE__*/function (_THREE$Group) {\n  _inherits(Position, _THREE$Group);\n  var _super = _createSuper(Position);\n  function Position() {\n    var _this;\n    _classCallCheck(this, Position);\n    _this = _super.call(this);\n    _this.color = new THREE.Color('white');\n    _this.instance = {\n      current: undefined\n    };\n    _this.instanceKey = {\n      current: undefined\n    };\n    return _this;\n  } // This will allow the virtual instance have bounds\n  _createClass(Position, [{\n    key: \"geometry\",\n    get: function get() {\n      var _this$instance$curren;\n      return (_this$instance$curren = this.instance.current) == null ? void 0 : _this$instance$curren.geometry;\n    } // And this will allow the virtual instance to receive events\n  }, {\n    key: \"raycast\",\n    value: function raycast(raycaster, intersects) {\n      var parent = this.instance.current;\n      if (!parent) return;\n      if (!parent.geometry || !parent.material) return;\n      _mesh.geometry = parent.geometry;\n      var matrixWorld = parent.matrixWorld;\n      var instanceId = parent.userData.instances.indexOf(this.instanceKey); // If the instance wasn't found or exceeds the parents draw range, bail out\n\n      if (instanceId === -1 || instanceId > parent.count) return; // calculate the world matrix for each instance\n\n      parent.getMatrixAt(instanceId, _instanceLocalMatrix);\n      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix); // the mesh represents this single instance\n\n      _mesh.matrixWorld = _instanceWorldMatrix;\n      _mesh.raycast(raycaster, _instanceIntersects); // process the result of raycast\n\n      for (var i = 0, l = _instanceIntersects.length; i < l; i++) {\n        var intersect = _instanceIntersects[i];\n        intersect.instanceId = instanceId;\n        intersect.object = this;\n        intersects.push(intersect);\n      }\n      _instanceIntersects.length = 0;\n    }\n  }]);\n  return Position;\n}(THREE.Group);\nexport { Position };","map":{"version":3,"names":["THREE","_instanceLocalMatrix","Matrix4","_instanceWorldMatrix","_instanceIntersects","_mesh","Mesh","Position","_THREE$Group","_inherits","_super","_createSuper","_this","_classCallCheck","call","color","Color","instance","current","undefined","instanceKey","_createClass","key","get","_this$instance$curren","geometry","value","raycast","raycaster","intersects","parent","material","matrixWorld","instanceId","userData","instances","indexOf","count","getMatrixAt","multiplyMatrices","i","l","length","intersect","object","push","Group"],"sources":["/Users/rizzytwizzy/Projects/idxntity/node_modules/@react-three/drei/helpers/Position.js"],"sourcesContent":["import * as THREE from 'three';\n\nconst _instanceLocalMatrix = /*@__PURE__*/new THREE.Matrix4();\n\nconst _instanceWorldMatrix = /*@__PURE__*/new THREE.Matrix4();\n\nconst _instanceIntersects = [];\n\nconst _mesh = /*@__PURE__*/new THREE.Mesh();\n\nclass Position extends THREE.Group {\n  constructor() {\n    super();\n    this.color = new THREE.Color('white');\n    this.instance = {\n      current: undefined\n    };\n    this.instanceKey = {\n      current: undefined\n    };\n  } // This will allow the virtual instance have bounds\n\n\n  get geometry() {\n    var _this$instance$curren;\n\n    return (_this$instance$curren = this.instance.current) == null ? void 0 : _this$instance$curren.geometry;\n  } // And this will allow the virtual instance to receive events\n\n\n  raycast(raycaster, intersects) {\n    const parent = this.instance.current;\n    if (!parent) return;\n    if (!parent.geometry || !parent.material) return;\n    _mesh.geometry = parent.geometry;\n    const matrixWorld = parent.matrixWorld;\n    let instanceId = parent.userData.instances.indexOf(this.instanceKey); // If the instance wasn't found or exceeds the parents draw range, bail out\n\n    if (instanceId === -1 || instanceId > parent.count) return; // calculate the world matrix for each instance\n\n    parent.getMatrixAt(instanceId, _instanceLocalMatrix);\n\n    _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix); // the mesh represents this single instance\n\n\n    _mesh.matrixWorld = _instanceWorldMatrix;\n\n    _mesh.raycast(raycaster, _instanceIntersects); // process the result of raycast\n\n\n    for (let i = 0, l = _instanceIntersects.length; i < l; i++) {\n      const intersect = _instanceIntersects[i];\n      intersect.instanceId = instanceId;\n      intersect.object = this;\n      intersects.push(intersect);\n    }\n\n    _instanceIntersects.length = 0;\n  }\n\n}\n\nexport { Position };\n"],"mappings":";;;;AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAE9B,IAAMC,oBAAoB,GAAG,aAAa,IAAID,KAAK,CAACE,OAAO,CAAC,CAAC;AAE7D,IAAMC,oBAAoB,GAAG,aAAa,IAAIH,KAAK,CAACE,OAAO,CAAC,CAAC;AAE7D,IAAME,mBAAmB,GAAG,EAAE;AAE9B,IAAMC,KAAK,GAAG,aAAa,IAAIL,KAAK,CAACM,IAAI,CAAC,CAAC;AAAC,IAEtCC,QAAQ,0BAAAC,YAAA;EAAAC,SAAA,CAAAF,QAAA,EAAAC,YAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,QAAA;EACZ,SAAAA,SAAA,EAAc;IAAA,IAAAK,KAAA;IAAAC,eAAA,OAAAN,QAAA;IACZK,KAAA,GAAAF,MAAA,CAAAI,IAAA;IACAF,KAAA,CAAKG,KAAK,GAAG,IAAIf,KAAK,CAACgB,KAAK,CAAC,OAAO,CAAC;IACrCJ,KAAA,CAAKK,QAAQ,GAAG;MACdC,OAAO,EAAEC;IACX,CAAC;IACDP,KAAA,CAAKQ,WAAW,GAAG;MACjBF,OAAO,EAAEC;IACX,CAAC;IAAC,OAAAP,KAAA;EACJ,CAAC,CAAC;EAAAS,YAAA,CAAAd,QAAA;IAAAe,GAAA;IAAAC,GAAA,EAGF,SAAAA,IAAA,EAAe;MACb,IAAIC,qBAAqB;MAEzB,OAAO,CAACA,qBAAqB,GAAG,IAAI,CAACP,QAAQ,CAACC,OAAO,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGM,qBAAqB,CAACC,QAAQ;IAC1G,CAAC,CAAC;EAAA;IAAAH,GAAA;IAAAI,KAAA,EAGF,SAAAC,QAAQC,SAAS,EAAEC,UAAU,EAAE;MAC7B,IAAMC,MAAM,GAAG,IAAI,CAACb,QAAQ,CAACC,OAAO;MACpC,IAAI,CAACY,MAAM,EAAE;MACb,IAAI,CAACA,MAAM,CAACL,QAAQ,IAAI,CAACK,MAAM,CAACC,QAAQ,EAAE;MAC1C1B,KAAK,CAACoB,QAAQ,GAAGK,MAAM,CAACL,QAAQ;MAChC,IAAMO,WAAW,GAAGF,MAAM,CAACE,WAAW;MACtC,IAAIC,UAAU,GAAGH,MAAM,CAACI,QAAQ,CAACC,SAAS,CAACC,OAAO,CAAC,IAAI,CAAChB,WAAW,CAAC,CAAC,CAAC;;MAEtE,IAAIa,UAAU,KAAK,CAAC,CAAC,IAAIA,UAAU,GAAGH,MAAM,CAACO,KAAK,EAAE,OAAO,CAAC;;MAE5DP,MAAM,CAACQ,WAAW,CAACL,UAAU,EAAEhC,oBAAoB,CAAC;MAEpDE,oBAAoB,CAACoC,gBAAgB,CAACP,WAAW,EAAE/B,oBAAoB,CAAC,CAAC,CAAC;;MAG1EI,KAAK,CAAC2B,WAAW,GAAG7B,oBAAoB;MAExCE,KAAK,CAACsB,OAAO,CAACC,SAAS,EAAExB,mBAAmB,CAAC,CAAC,CAAC;;MAG/C,KAAK,IAAIoC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGrC,mBAAmB,CAACsC,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;QAC1D,IAAMG,SAAS,GAAGvC,mBAAmB,CAACoC,CAAC,CAAC;QACxCG,SAAS,CAACV,UAAU,GAAGA,UAAU;QACjCU,SAAS,CAACC,MAAM,GAAG,IAAI;QACvBf,UAAU,CAACgB,IAAI,CAACF,SAAS,CAAC;MAC5B;MAEAvC,mBAAmB,CAACsC,MAAM,GAAG,CAAC;IAChC;EAAC;EAAA,OAAAnC,QAAA;AAAA,EAhDoBP,KAAK,CAAC8C,KAAK;AAoDlC,SAASvC,QAAQ"},"metadata":{},"sourceType":"module","externalDependencies":[]}