{"ast":null,"code":"import _classCallCheck from \"/Users/rizzytwizzy/Projects/idxntity/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rizzytwizzy/Projects/idxntity/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/rizzytwizzy/Projects/idxntity/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/Users/rizzytwizzy/Projects/idxntity/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/rizzytwizzy/Projects/idxntity/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/rizzytwizzy/Projects/idxntity/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/rizzytwizzy/Projects/idxntity/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport * as THREE from \"three\";\nvar PINCH_MAX = 0.05;\nvar PINCH_THRESHOLD = 0.02;\nvar PINCH_MIN = 0.01;\nvar POINTER_ADVANCE_MAX = 0.02;\nvar POINTER_OPACITY_MAX = 1;\nvar POINTER_OPACITY_MIN = 0.4;\nvar POINTER_FRONT_RADIUS = 2e-3;\nvar POINTER_REAR_RADIUS = 0.01;\nvar POINTER_REAR_RADIUS_MIN = 3e-3;\nvar POINTER_LENGTH = 0.035;\nvar POINTER_SEGMENTS = 16;\nvar POINTER_RINGS = 12;\nvar POINTER_HEMISPHERE_ANGLE = 110;\nvar YAXIS = /* @__PURE__ */new THREE.Vector3(0, 1, 0);\nvar ZAXIS = /* @__PURE__ */new THREE.Vector3(0, 0, 1);\nvar CURSOR_RADIUS = 0.02;\nvar CURSOR_MAX_DISTANCE = 1.5;\nvar OculusHandPointerModel = /*#__PURE__*/function (_THREE$Object3D) {\n  _inherits(OculusHandPointerModel, _THREE$Object3D);\n  var _super = _createSuper(OculusHandPointerModel);\n  function OculusHandPointerModel(hand, controller) {\n    var _this;\n    _classCallCheck(this, OculusHandPointerModel);\n    _this = _super.call(this);\n    _this.hand = hand;\n    _this.controller = controller;\n    _this.motionController = null;\n    _this.envMap = null;\n    _this.mesh = null;\n    _this.pointerGeometry = null;\n    _this.pointerMesh = null;\n    _this.pointerObject = null;\n    _this.pinched = false;\n    _this.attached = false;\n    _this.cursorObject = null;\n    _this.raycaster = null;\n    _this._onConnected = _this._onConnected.bind(_assertThisInitialized(_this));\n    _this._onDisconnected = _this._onDisconnected.bind(_assertThisInitialized(_this));\n    _this.hand.addEventListener(\"connected\", _this._onConnected);\n    _this.hand.addEventListener(\"disconnected\", _this._onDisconnected);\n    return _this;\n  }\n  _createClass(OculusHandPointerModel, [{\n    key: \"_onConnected\",\n    value: function _onConnected(event) {\n      var xrInputSource = event.data;\n      if (xrInputSource.hand) {\n        this.visible = true;\n        this.xrInputSource = xrInputSource;\n        this.createPointer();\n      }\n    }\n  }, {\n    key: \"_onDisconnected\",\n    value: function _onDisconnected() {\n      var _a, _b;\n      this.visible = false;\n      this.xrInputSource = null;\n      (_a = this.pointerGeometry) == null ? void 0 : _a.dispose();\n      (_b = this.pointerMesh) == null ? void 0 : _b.material.dispose();\n      this.clear();\n    }\n  }, {\n    key: \"_drawVerticesRing\",\n    value: function _drawVerticesRing(vertices, baseVector, ringIndex) {\n      var segmentVector = baseVector.clone();\n      for (var i = 0; i < POINTER_SEGMENTS; i++) {\n        segmentVector.applyAxisAngle(ZAXIS, Math.PI * 2 / POINTER_SEGMENTS);\n        var vid = ringIndex * POINTER_SEGMENTS + i;\n        vertices[3 * vid] = segmentVector.x;\n        vertices[3 * vid + 1] = segmentVector.y;\n        vertices[3 * vid + 2] = segmentVector.z;\n      }\n    }\n  }, {\n    key: \"_updatePointerVertices\",\n    value: function _updatePointerVertices(rearRadius) {\n      var vertices = this.pointerGeometry.attributes.position.array;\n      var frontFaceBase = new THREE.Vector3(POINTER_FRONT_RADIUS, 0, -1 * (POINTER_LENGTH - rearRadius));\n      this._drawVerticesRing(vertices, frontFaceBase, 0);\n      var rearBase = new THREE.Vector3(Math.sin(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, Math.cos(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, 0);\n      for (var i = 0; i < POINTER_RINGS; i++) {\n        this._drawVerticesRing(vertices, rearBase, i + 1);\n        rearBase.applyAxisAngle(YAXIS, Math.PI * POINTER_HEMISPHERE_ANGLE / 180 / (POINTER_RINGS * -2));\n      }\n      var frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n      var rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n      var frontCenter = new THREE.Vector3(0, 0, -1 * (POINTER_LENGTH - rearRadius));\n      vertices[frontCenterIndex * 3] = frontCenter.x;\n      vertices[frontCenterIndex * 3 + 1] = frontCenter.y;\n      vertices[frontCenterIndex * 3 + 2] = frontCenter.z;\n      var rearCenter = new THREE.Vector3(0, 0, rearRadius);\n      vertices[rearCenterIndex * 3] = rearCenter.x;\n      vertices[rearCenterIndex * 3 + 1] = rearCenter.y;\n      vertices[rearCenterIndex * 3 + 2] = rearCenter.z;\n      this.pointerGeometry.setAttribute(\"position\", new THREE.Float32BufferAttribute(vertices, 3));\n    }\n  }, {\n    key: \"createPointer\",\n    value: function createPointer() {\n      var i, j;\n      var vertices = new Array(((POINTER_RINGS + 1) * POINTER_SEGMENTS + 2) * 3).fill(0);\n      var indices = [];\n      this.pointerGeometry = new THREE.BufferGeometry();\n      this.pointerGeometry.setAttribute(\"position\", new THREE.Float32BufferAttribute(vertices, 3));\n      this._updatePointerVertices(POINTER_REAR_RADIUS);\n      for (i = 0; i < POINTER_RINGS; i++) {\n        for (j = 0; j < POINTER_SEGMENTS - 1; j++) {\n          indices.push(i * POINTER_SEGMENTS + j, i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n          indices.push(i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n        }\n        indices.push((i + 1) * POINTER_SEGMENTS - 1, i * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n        indices.push(i * POINTER_SEGMENTS, (i + 1) * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n      }\n      var frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n      var rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n      for (i = 0; i < POINTER_SEGMENTS - 1; i++) {\n        indices.push(frontCenterIndex, i + 1, i);\n        indices.push(rearCenterIndex, i + POINTER_SEGMENTS * POINTER_RINGS, i + POINTER_SEGMENTS * POINTER_RINGS + 1);\n      }\n      indices.push(frontCenterIndex, 0, POINTER_SEGMENTS - 1);\n      indices.push(rearCenterIndex, POINTER_SEGMENTS * (POINTER_RINGS + 1) - 1, POINTER_SEGMENTS * POINTER_RINGS);\n      var material = new THREE.MeshBasicMaterial();\n      material.transparent = true;\n      material.opacity = POINTER_OPACITY_MIN;\n      this.pointerGeometry.setIndex(indices);\n      this.pointerMesh = new THREE.Mesh(this.pointerGeometry, material);\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n      this.pointerObject = new THREE.Object3D();\n      this.pointerObject.add(this.pointerMesh);\n      this.raycaster = new THREE.Raycaster();\n      var cursorGeometry = new THREE.SphereGeometry(CURSOR_RADIUS, 10, 10);\n      var cursorMaterial = new THREE.MeshBasicMaterial();\n      cursorMaterial.transparent = true;\n      cursorMaterial.opacity = POINTER_OPACITY_MIN;\n      this.cursorObject = new THREE.Mesh(cursorGeometry, cursorMaterial);\n      this.pointerObject.add(this.cursorObject);\n      this.add(this.pointerObject);\n    }\n  }, {\n    key: \"_updateRaycaster\",\n    value: function _updateRaycaster() {\n      if (this.raycaster) {\n        var pointerMatrix = this.pointerObject.matrixWorld;\n        var tempMatrix = new THREE.Matrix4();\n        tempMatrix.identity().extractRotation(pointerMatrix);\n        this.raycaster.ray.origin.setFromMatrixPosition(pointerMatrix);\n        this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);\n      }\n    }\n  }, {\n    key: \"_updatePointer\",\n    value: function _updatePointer() {\n      this.pointerObject.visible = this.controller.visible;\n      var indexTip = this.hand.joints[\"index-finger-tip\"];\n      var thumbTip = this.hand.joints[\"thumb-tip\"];\n      var distance = indexTip.position.distanceTo(thumbTip.position);\n      var position = indexTip.position.clone().add(thumbTip.position).multiplyScalar(0.5);\n      this.pointerObject.position.copy(position);\n      this.pointerObject.quaternion.copy(this.controller.quaternion);\n      this.pinched = distance <= PINCH_THRESHOLD;\n      var pinchScale = (distance - PINCH_MIN) / (PINCH_MAX - PINCH_MIN);\n      var focusScale = (distance - PINCH_MIN) / (PINCH_THRESHOLD - PINCH_MIN);\n      if (pinchScale > 1) {\n        this._updatePointerVertices(POINTER_REAR_RADIUS);\n        this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n      } else if (pinchScale > 0) {\n        var rearRadius = (POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN) * pinchScale + POINTER_REAR_RADIUS_MIN;\n        this._updatePointerVertices(rearRadius);\n        if (focusScale < 1) {\n          this.pointerMesh.position.set(0, 0, -1 * rearRadius - (1 - focusScale) * POINTER_ADVANCE_MAX);\n          this.pointerMesh.material.opacity = POINTER_OPACITY_MIN + (1 - focusScale) * (POINTER_OPACITY_MAX - POINTER_OPACITY_MIN);\n        } else {\n          this.pointerMesh.position.set(0, 0, -1 * rearRadius);\n          this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n        }\n      } else {\n        this._updatePointerVertices(POINTER_REAR_RADIUS_MIN);\n        this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MAX;\n      }\n      this.cursorObject.material.opacity = this.pointerMesh.material.opacity;\n    }\n  }, {\n    key: \"updateMatrixWorld\",\n    value: function updateMatrixWorld(force) {\n      _get(_getPrototypeOf(OculusHandPointerModel.prototype), \"updateMatrixWorld\", this).call(this, force);\n      if (this.pointerGeometry) {\n        this._updatePointer();\n        this._updateRaycaster();\n      }\n    }\n  }, {\n    key: \"isPinched\",\n    value: function isPinched() {\n      return this.pinched;\n    }\n  }, {\n    key: \"setAttached\",\n    value: function setAttached(attached) {\n      this.attached = attached;\n    }\n  }, {\n    key: \"isAttached\",\n    value: function isAttached() {\n      return this.attached;\n    }\n  }, {\n    key: \"intersectObject\",\n    value: function intersectObject(object) {\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (this.raycaster) {\n        return this.raycaster.intersectObject(object, recursive);\n      }\n    }\n  }, {\n    key: \"intersectObjects\",\n    value: function intersectObjects(objects) {\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (this.raycaster) {\n        return this.raycaster.intersectObjects(objects, recursive);\n      }\n    }\n  }, {\n    key: \"checkIntersections\",\n    value: function checkIntersections(objects) {\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (this.raycaster && !this.attached) {\n        var intersections = this.raycaster.intersectObjects(objects, recursive);\n        var direction = new THREE.Vector3(0, 0, -1);\n        if (intersections.length > 0) {\n          var intersection = intersections[0];\n          var distance = intersection.distance;\n          this.cursorObject.position.copy(direction.multiplyScalar(distance));\n        } else {\n          this.cursorObject.position.copy(direction.multiplyScalar(CURSOR_MAX_DISTANCE));\n        }\n      }\n    }\n  }, {\n    key: \"setCursor\",\n    value: function setCursor(distance) {\n      var direction = new THREE.Vector3(0, 0, -1);\n      if (this.raycaster && !this.attached) {\n        this.cursorObject.position.copy(direction.multiplyScalar(distance));\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this._onDisconnected();\n      this.hand.removeEventListener(\"connected\", this._onConnected);\n      this.hand.removeEventListener(\"disconnected\", this._onDisconnected);\n    }\n  }]);\n  return OculusHandPointerModel;\n}(THREE.Object3D);\nexport { OculusHandPointerModel };","map":{"version":3,"names":["THREE","PINCH_MAX","PINCH_THRESHOLD","PINCH_MIN","POINTER_ADVANCE_MAX","POINTER_OPACITY_MAX","POINTER_OPACITY_MIN","POINTER_FRONT_RADIUS","POINTER_REAR_RADIUS","POINTER_REAR_RADIUS_MIN","POINTER_LENGTH","POINTER_SEGMENTS","POINTER_RINGS","POINTER_HEMISPHERE_ANGLE","YAXIS","Vector3","ZAXIS","CURSOR_RADIUS","CURSOR_MAX_DISTANCE","OculusHandPointerModel","_THREE$Object3D","_inherits","_super","_createSuper","hand","controller","_this","_classCallCheck","call","motionController","envMap","mesh","pointerGeometry","pointerMesh","pointerObject","pinched","attached","cursorObject","raycaster","_onConnected","bind","_assertThisInitialized","_onDisconnected","addEventListener","_createClass","key","value","event","xrInputSource","data","visible","createPointer","_a","_b","dispose","material","clear","_drawVerticesRing","vertices","baseVector","ringIndex","segmentVector","clone","i","applyAxisAngle","Math","PI","vid","x","y","z","_updatePointerVertices","rearRadius","attributes","position","array","frontFaceBase","rearBase","sin","cos","frontCenterIndex","rearCenterIndex","frontCenter","rearCenter","setAttribute","Float32BufferAttribute","j","Array","fill","indices","BufferGeometry","push","MeshBasicMaterial","transparent","opacity","setIndex","Mesh","set","Object3D","add","Raycaster","cursorGeometry","SphereGeometry","cursorMaterial","_updateRaycaster","pointerMatrix","matrixWorld","tempMatrix","Matrix4","identity","extractRotation","ray","origin","setFromMatrixPosition","direction","applyMatrix4","_updatePointer","indexTip","joints","thumbTip","distance","distanceTo","multiplyScalar","copy","quaternion","pinchScale","focusScale","updateMatrixWorld","force","_get","_getPrototypeOf","prototype","isPinched","setAttached","isAttached","intersectObject","object","recursive","arguments","length","undefined","intersectObjects","objects","checkIntersections","intersections","intersection","setCursor","removeEventListener"],"sources":["/Users/rizzytwizzy/Projects/idxntity/node_modules/three-stdlib/webxr/OculusHandPointerModel.js"],"sourcesContent":["import * as THREE from \"three\";\nconst PINCH_MAX = 0.05;\nconst PINCH_THRESHOLD = 0.02;\nconst PINCH_MIN = 0.01;\nconst POINTER_ADVANCE_MAX = 0.02;\nconst POINTER_OPACITY_MAX = 1;\nconst POINTER_OPACITY_MIN = 0.4;\nconst POINTER_FRONT_RADIUS = 2e-3;\nconst POINTER_REAR_RADIUS = 0.01;\nconst POINTER_REAR_RADIUS_MIN = 3e-3;\nconst POINTER_LENGTH = 0.035;\nconst POINTER_SEGMENTS = 16;\nconst POINTER_RINGS = 12;\nconst POINTER_HEMISPHERE_ANGLE = 110;\nconst YAXIS = /* @__PURE__ */ new THREE.Vector3(0, 1, 0);\nconst ZAXIS = /* @__PURE__ */ new THREE.Vector3(0, 0, 1);\nconst CURSOR_RADIUS = 0.02;\nconst CURSOR_MAX_DISTANCE = 1.5;\nclass OculusHandPointerModel extends THREE.Object3D {\n  constructor(hand, controller) {\n    super();\n    this.hand = hand;\n    this.controller = controller;\n    this.motionController = null;\n    this.envMap = null;\n    this.mesh = null;\n    this.pointerGeometry = null;\n    this.pointerMesh = null;\n    this.pointerObject = null;\n    this.pinched = false;\n    this.attached = false;\n    this.cursorObject = null;\n    this.raycaster = null;\n    this._onConnected = this._onConnected.bind(this);\n    this._onDisconnected = this._onDisconnected.bind(this);\n    this.hand.addEventListener(\"connected\", this._onConnected);\n    this.hand.addEventListener(\"disconnected\", this._onDisconnected);\n  }\n  _onConnected(event) {\n    const xrInputSource = event.data;\n    if (xrInputSource.hand) {\n      this.visible = true;\n      this.xrInputSource = xrInputSource;\n      this.createPointer();\n    }\n  }\n  _onDisconnected() {\n    var _a, _b;\n    this.visible = false;\n    this.xrInputSource = null;\n    (_a = this.pointerGeometry) == null ? void 0 : _a.dispose();\n    (_b = this.pointerMesh) == null ? void 0 : _b.material.dispose();\n    this.clear();\n  }\n  _drawVerticesRing(vertices, baseVector, ringIndex) {\n    const segmentVector = baseVector.clone();\n    for (var i = 0; i < POINTER_SEGMENTS; i++) {\n      segmentVector.applyAxisAngle(ZAXIS, Math.PI * 2 / POINTER_SEGMENTS);\n      const vid = ringIndex * POINTER_SEGMENTS + i;\n      vertices[3 * vid] = segmentVector.x;\n      vertices[3 * vid + 1] = segmentVector.y;\n      vertices[3 * vid + 2] = segmentVector.z;\n    }\n  }\n  _updatePointerVertices(rearRadius) {\n    const vertices = this.pointerGeometry.attributes.position.array;\n    const frontFaceBase = new THREE.Vector3(POINTER_FRONT_RADIUS, 0, -1 * (POINTER_LENGTH - rearRadius));\n    this._drawVerticesRing(vertices, frontFaceBase, 0);\n    const rearBase = new THREE.Vector3(\n      Math.sin(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius,\n      Math.cos(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius,\n      0\n    );\n    for (var i = 0; i < POINTER_RINGS; i++) {\n      this._drawVerticesRing(vertices, rearBase, i + 1);\n      rearBase.applyAxisAngle(YAXIS, Math.PI * POINTER_HEMISPHERE_ANGLE / 180 / (POINTER_RINGS * -2));\n    }\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n    const frontCenter = new THREE.Vector3(0, 0, -1 * (POINTER_LENGTH - rearRadius));\n    vertices[frontCenterIndex * 3] = frontCenter.x;\n    vertices[frontCenterIndex * 3 + 1] = frontCenter.y;\n    vertices[frontCenterIndex * 3 + 2] = frontCenter.z;\n    const rearCenter = new THREE.Vector3(0, 0, rearRadius);\n    vertices[rearCenterIndex * 3] = rearCenter.x;\n    vertices[rearCenterIndex * 3 + 1] = rearCenter.y;\n    vertices[rearCenterIndex * 3 + 2] = rearCenter.z;\n    this.pointerGeometry.setAttribute(\"position\", new THREE.Float32BufferAttribute(vertices, 3));\n  }\n  createPointer() {\n    var i, j;\n    const vertices = new Array(((POINTER_RINGS + 1) * POINTER_SEGMENTS + 2) * 3).fill(0);\n    const indices = [];\n    this.pointerGeometry = new THREE.BufferGeometry();\n    this.pointerGeometry.setAttribute(\"position\", new THREE.Float32BufferAttribute(vertices, 3));\n    this._updatePointerVertices(POINTER_REAR_RADIUS);\n    for (i = 0; i < POINTER_RINGS; i++) {\n      for (j = 0; j < POINTER_SEGMENTS - 1; j++) {\n        indices.push(i * POINTER_SEGMENTS + j, i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n        indices.push(i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n      }\n      indices.push((i + 1) * POINTER_SEGMENTS - 1, i * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n      indices.push(i * POINTER_SEGMENTS, (i + 1) * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n    }\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n    for (i = 0; i < POINTER_SEGMENTS - 1; i++) {\n      indices.push(frontCenterIndex, i + 1, i);\n      indices.push(rearCenterIndex, i + POINTER_SEGMENTS * POINTER_RINGS, i + POINTER_SEGMENTS * POINTER_RINGS + 1);\n    }\n    indices.push(frontCenterIndex, 0, POINTER_SEGMENTS - 1);\n    indices.push(rearCenterIndex, POINTER_SEGMENTS * (POINTER_RINGS + 1) - 1, POINTER_SEGMENTS * POINTER_RINGS);\n    const material = new THREE.MeshBasicMaterial();\n    material.transparent = true;\n    material.opacity = POINTER_OPACITY_MIN;\n    this.pointerGeometry.setIndex(indices);\n    this.pointerMesh = new THREE.Mesh(this.pointerGeometry, material);\n    this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n    this.pointerObject = new THREE.Object3D();\n    this.pointerObject.add(this.pointerMesh);\n    this.raycaster = new THREE.Raycaster();\n    const cursorGeometry = new THREE.SphereGeometry(CURSOR_RADIUS, 10, 10);\n    const cursorMaterial = new THREE.MeshBasicMaterial();\n    cursorMaterial.transparent = true;\n    cursorMaterial.opacity = POINTER_OPACITY_MIN;\n    this.cursorObject = new THREE.Mesh(cursorGeometry, cursorMaterial);\n    this.pointerObject.add(this.cursorObject);\n    this.add(this.pointerObject);\n  }\n  _updateRaycaster() {\n    if (this.raycaster) {\n      const pointerMatrix = this.pointerObject.matrixWorld;\n      const tempMatrix = new THREE.Matrix4();\n      tempMatrix.identity().extractRotation(pointerMatrix);\n      this.raycaster.ray.origin.setFromMatrixPosition(pointerMatrix);\n      this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);\n    }\n  }\n  _updatePointer() {\n    this.pointerObject.visible = this.controller.visible;\n    const indexTip = this.hand.joints[\"index-finger-tip\"];\n    const thumbTip = this.hand.joints[\"thumb-tip\"];\n    const distance = indexTip.position.distanceTo(thumbTip.position);\n    const position = indexTip.position.clone().add(thumbTip.position).multiplyScalar(0.5);\n    this.pointerObject.position.copy(position);\n    this.pointerObject.quaternion.copy(this.controller.quaternion);\n    this.pinched = distance <= PINCH_THRESHOLD;\n    const pinchScale = (distance - PINCH_MIN) / (PINCH_MAX - PINCH_MIN);\n    const focusScale = (distance - PINCH_MIN) / (PINCH_THRESHOLD - PINCH_MIN);\n    if (pinchScale > 1) {\n      this._updatePointerVertices(POINTER_REAR_RADIUS);\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n    } else if (pinchScale > 0) {\n      const rearRadius = (POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN) * pinchScale + POINTER_REAR_RADIUS_MIN;\n      this._updatePointerVertices(rearRadius);\n      if (focusScale < 1) {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius - (1 - focusScale) * POINTER_ADVANCE_MAX);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN + (1 - focusScale) * (POINTER_OPACITY_MAX - POINTER_OPACITY_MIN);\n      } else {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n      }\n    } else {\n      this._updatePointerVertices(POINTER_REAR_RADIUS_MIN);\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX);\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MAX;\n    }\n    this.cursorObject.material.opacity = this.pointerMesh.material.opacity;\n  }\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n    if (this.pointerGeometry) {\n      this._updatePointer();\n      this._updateRaycaster();\n    }\n  }\n  isPinched() {\n    return this.pinched;\n  }\n  setAttached(attached) {\n    this.attached = attached;\n  }\n  isAttached() {\n    return this.attached;\n  }\n  intersectObject(object, recursive = true) {\n    if (this.raycaster) {\n      return this.raycaster.intersectObject(object, recursive);\n    }\n  }\n  intersectObjects(objects, recursive = true) {\n    if (this.raycaster) {\n      return this.raycaster.intersectObjects(objects, recursive);\n    }\n  }\n  checkIntersections(objects, recursive = false) {\n    if (this.raycaster && !this.attached) {\n      const intersections = this.raycaster.intersectObjects(objects, recursive);\n      const direction = new THREE.Vector3(0, 0, -1);\n      if (intersections.length > 0) {\n        const intersection = intersections[0];\n        const distance = intersection.distance;\n        this.cursorObject.position.copy(direction.multiplyScalar(distance));\n      } else {\n        this.cursorObject.position.copy(direction.multiplyScalar(CURSOR_MAX_DISTANCE));\n      }\n    }\n  }\n  setCursor(distance) {\n    const direction = new THREE.Vector3(0, 0, -1);\n    if (this.raycaster && !this.attached) {\n      this.cursorObject.position.copy(direction.multiplyScalar(distance));\n    }\n  }\n  dispose() {\n    this._onDisconnected();\n    this.hand.removeEventListener(\"connected\", this._onConnected);\n    this.hand.removeEventListener(\"disconnected\", this._onDisconnected);\n  }\n}\nexport {\n  OculusHandPointerModel\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}