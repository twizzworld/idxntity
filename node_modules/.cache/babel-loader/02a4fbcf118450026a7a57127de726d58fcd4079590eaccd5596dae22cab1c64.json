{"ast":null,"code":"import _objectSpread from \"/Users/rizzytwizzy/Projects/idxntity/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport * as THREE from 'three';\nvar pcss = function pcss() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n    _ref$frustum = _ref.frustum,\n    frustum = _ref$frustum === void 0 ? 3.75 : _ref$frustum,\n    _ref$size = _ref.size,\n    size = _ref$size === void 0 ? 0.005 : _ref$size,\n    _ref$near = _ref.near,\n    near = _ref$near === void 0 ? 9.5 : _ref$near,\n    _ref$samples = _ref.samples,\n    samples = _ref$samples === void 0 ? 17 : _ref$samples,\n    _ref$rings = _ref.rings,\n    rings = _ref$rings === void 0 ? 11 : _ref$rings;\n  return \"#define LIGHT_WORLD_SIZE \".concat(size, \"\\n#define LIGHT_FRUSTUM_WIDTH \").concat(frustum, \"\\n#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\\n#define NEAR_PLANE \").concat(near, \"\\n\\n#define NUM_SAMPLES \").concat(samples, \"\\n#define NUM_RINGS \").concat(rings, \"\\n#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\\n#define PCF_NUM_SAMPLES NUM_SAMPLES\\n\\nvec2 poissonDisk[NUM_SAMPLES];\\n\\nvoid initPoissonSamples(const in vec2 randomSeed) {\\n  float ANGLE_STEP = PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);\\n  float INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);\\n  float angle = rand(randomSeed) * PI2;\\n  float radius = INV_NUM_SAMPLES;\\n  float radiusStep = radius;\\n  for (int i = 0; i < NUM_SAMPLES; i++) {\\n    poissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);\\n    radius += radiusStep;\\n    angle += ANGLE_STEP;\\n  }\\n}\\n\\nfloat penumbraSize(const in float zReceiver, const in float zBlocker) { // Parallel plane estimation\\n  return (zReceiver - zBlocker) / zBlocker;\\n}\\n\\nfloat findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver) {\\n  float searchRadius = LIGHT_SIZE_UV * (zReceiver - NEAR_PLANE) / zReceiver;\\n  float blockerDepthSum = 0.0;\\n  int numBlockers = 0;\\n  for (int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++) {\\n    float shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\\n    if (shadowMapDepth < zReceiver) {\\n      blockerDepthSum += shadowMapDepth;\\n      numBlockers++;\\n    }\\n  }\\n  if (numBlockers == 0) return -1.0;\\n  return blockerDepthSum / float(numBlockers);\\n}\\n\\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {\\n  float sum = 0.0;\\n  for (int i = 0; i < PCF_NUM_SAMPLES; i++) {\\n    float depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[ i ] * filterRadius));\\n    if (zReceiver <= depth) sum += 1.0;\\n  }\\n  for (int i = 0; i < PCF_NUM_SAMPLES; i++) {\\n    float depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[ i ].yx * filterRadius));\\n    if (zReceiver <= depth) sum += 1.0;\\n  }\\n  return sum / (2.0 * float(PCF_NUM_SAMPLES));\\n}\\n\\nfloat PCSS(sampler2D shadowMap, vec4 coords) {\\n  vec2 uv = coords.xy;\\n  float zReceiver = coords.z; // Assumed to be eye-space z in this code\\n  initPoissonSamples(uv);\\n  float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);\\n  if (avgBlockerDepth == -1.0) return 1.0;\\n  float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\\n  float filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\\n  return PCF_Filter(shadowMap, uv, zReceiver, filterRadius);\\n}\");\n};\nvar deployed = false;\nvar softShadows = function softShadows(props) {\n  // Avoid adding the effect twice, which may happen in HMR scenarios\n  if (!deployed) {\n    deployed = true;\n    var shader = THREE.ShaderChunk.shadowmap_pars_fragment;\n    shader = shader.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP\\n' + pcss(_objectSpread({}, props)));\n    shader = shader.replace('#if defined( SHADOWMAP_TYPE_PCF )', '\\nreturn PCSS(shadowMap, shadowCoord);\\n#if defined( SHADOWMAP_TYPE_PCF )');\n    THREE.ShaderChunk.shadowmap_pars_fragment = shader;\n  }\n};\nexport { softShadows };","map":{"version":3,"names":["THREE","pcss","_ref","arguments","length","undefined","_ref$frustum","frustum","_ref$size","size","_ref$near","near","_ref$samples","samples","_ref$rings","rings","concat","deployed","softShadows","props","shader","ShaderChunk","shadowmap_pars_fragment","replace","_objectSpread"],"sources":["/Users/rizzytwizzy/Projects/idxntity/node_modules/@react-three/drei/core/softShadows.js"],"sourcesContent":["import * as THREE from 'three';\n\nconst pcss = ({\n  frustum = 3.75,\n  size = 0.005,\n  near = 9.5,\n  samples = 17,\n  rings = 11\n} = {}) => `#define LIGHT_WORLD_SIZE ${size}\n#define LIGHT_FRUSTUM_WIDTH ${frustum}\n#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\n#define NEAR_PLANE ${near}\n\n#define NUM_SAMPLES ${samples}\n#define NUM_RINGS ${rings}\n#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\n#define PCF_NUM_SAMPLES NUM_SAMPLES\n\nvec2 poissonDisk[NUM_SAMPLES];\n\nvoid initPoissonSamples(const in vec2 randomSeed) {\n  float ANGLE_STEP = PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);\n  float INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);\n  float angle = rand(randomSeed) * PI2;\n  float radius = INV_NUM_SAMPLES;\n  float radiusStep = radius;\n  for (int i = 0; i < NUM_SAMPLES; i++) {\n    poissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);\n    radius += radiusStep;\n    angle += ANGLE_STEP;\n  }\n}\n\nfloat penumbraSize(const in float zReceiver, const in float zBlocker) { // Parallel plane estimation\n  return (zReceiver - zBlocker) / zBlocker;\n}\n\nfloat findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver) {\n  float searchRadius = LIGHT_SIZE_UV * (zReceiver - NEAR_PLANE) / zReceiver;\n  float blockerDepthSum = 0.0;\n  int numBlockers = 0;\n  for (int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++) {\n    float shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\n    if (shadowMapDepth < zReceiver) {\n      blockerDepthSum += shadowMapDepth;\n      numBlockers++;\n    }\n  }\n  if (numBlockers == 0) return -1.0;\n  return blockerDepthSum / float(numBlockers);\n}\n\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {\n  float sum = 0.0;\n  for (int i = 0; i < PCF_NUM_SAMPLES; i++) {\n    float depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[ i ] * filterRadius));\n    if (zReceiver <= depth) sum += 1.0;\n  }\n  for (int i = 0; i < PCF_NUM_SAMPLES; i++) {\n    float depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[ i ].yx * filterRadius));\n    if (zReceiver <= depth) sum += 1.0;\n  }\n  return sum / (2.0 * float(PCF_NUM_SAMPLES));\n}\n\nfloat PCSS(sampler2D shadowMap, vec4 coords) {\n  vec2 uv = coords.xy;\n  float zReceiver = coords.z; // Assumed to be eye-space z in this code\n  initPoissonSamples(uv);\n  float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);\n  if (avgBlockerDepth == -1.0) return 1.0;\n  float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\n  float filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\n  return PCF_Filter(shadowMap, uv, zReceiver, filterRadius);\n}`;\n\nlet deployed = false;\nconst softShadows = props => {\n  // Avoid adding the effect twice, which may happen in HMR scenarios\n  if (!deployed) {\n    deployed = true;\n    let shader = THREE.ShaderChunk.shadowmap_pars_fragment;\n    shader = shader.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP\\n' + pcss({ ...props\n    }));\n    shader = shader.replace('#if defined( SHADOWMAP_TYPE_PCF )', '\\nreturn PCSS(shadowMap, shadowCoord);\\n#if defined( SHADOWMAP_TYPE_PCF )');\n    THREE.ShaderChunk.shadowmap_pars_fragment = shader;\n  }\n};\n\nexport { softShadows };\n"],"mappings":";AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAE9B,IAAMC,IAAI,GAAG,SAAPA,IAAIA,CAAA;EAAA,IAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAMN,CAAC,CAAC;IAAAG,YAAA,GAAAJ,IAAA,CALJK,OAAO;IAAPA,OAAO,GAAAD,YAAA,cAAG,IAAI,GAAAA,YAAA;IAAAE,SAAA,GAAAN,IAAA,CACdO,IAAI;IAAJA,IAAI,GAAAD,SAAA,cAAG,KAAK,GAAAA,SAAA;IAAAE,SAAA,GAAAR,IAAA,CACZS,IAAI;IAAJA,IAAI,GAAAD,SAAA,cAAG,GAAG,GAAAA,SAAA;IAAAE,YAAA,GAAAV,IAAA,CACVW,OAAO;IAAPA,OAAO,GAAAD,YAAA,cAAG,EAAE,GAAAA,YAAA;IAAAE,UAAA,GAAAZ,IAAA,CACZa,KAAK;IAALA,KAAK,GAAAD,UAAA,cAAG,EAAE,GAAAA,UAAA;EAAA,mCAAAE,MAAA,CAC2BP,IAAI,oCAAAO,MAAA,CACbT,OAAO,2FAAAS,MAAA,CAEhBL,IAAI,8BAAAK,MAAA,CAEHH,OAAO,0BAAAG,MAAA,CACTD,KAAK;AAAA,CA4DvB;AAEF,IAAIE,QAAQ,GAAG,KAAK;AACpB,IAAMC,WAAW,GAAG,SAAdA,WAAWA,CAAGC,KAAK,EAAI;EAC3B;EACA,IAAI,CAACF,QAAQ,EAAE;IACbA,QAAQ,GAAG,IAAI;IACf,IAAIG,MAAM,GAAGpB,KAAK,CAACqB,WAAW,CAACC,uBAAuB;IACtDF,MAAM,GAAGA,MAAM,CAACG,OAAO,CAAC,sBAAsB,EAAE,wBAAwB,GAAGtB,IAAI,CAAAuB,aAAA,KAAML,KAAK,CACzF,CAAC,CAAC;IACHC,MAAM,GAAGA,MAAM,CAACG,OAAO,CAAC,mCAAmC,EAAE,2EAA2E,CAAC;IACzIvB,KAAK,CAACqB,WAAW,CAACC,uBAAuB,GAAGF,MAAM;EACpD;AACF,CAAC;AAED,SAASF,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}